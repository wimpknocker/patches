From 210590c682f0f5b8fc2ae47b98b6c908aef62034 Mon Sep 17 00:00:00 2001
From: "wimpknocker@wimpnether" <wimpknocker@wimpnether.net>
Date: Sun, 28 Jun 2015 23:49:49 +0300
Subject: [PATCH] 001-STE-OMX-AV-REWORK

Change-Id: I10ed45bfa7c609418a257f0d65ba73219b1c490f
---
 camera/CameraParameters.cpp                        |  23 +
 cmds/stagefright/recordvideo.cpp                   |  63 +-
 include/camera/CameraParameters.h                  |  23 +
 include/media/stagefright/ColorConverter.h         |   5 +
 include/media/stagefright/DataSource.h             |   5 +
 include/media/stagefright/MediaDefs.h              |   8 +
 include/media/stagefright/MediaErrors.h            |   8 +-
 include/media/stagefright/MetaData.h               |  12 +
 include/media/stagefright/OMXCodec.h               |   8 +
 include/media/stagefright/SurfaceMediaSource.h     |  32 +-
 include/media/stagefright/foundation/ABitReader.h  |   3 +
 media/libmedia/AudioTrack.cpp                      |   2 +
 .../libmediaplayerservice/StagefrightRecorder.cpp  |  14 +-
 media/libstagefright/ACodec.cpp                    |  15 +-
 media/libstagefright/ASFExtractor.cpp              | 853 +++++++++++++++++++++
 media/libstagefright/AVIExtractor.cpp              | 223 +++++-
 media/libstagefright/Android.mk                    |   8 +-
 media/libstagefright/AwesomePlayer.cpp             |   3 +-
 media/libstagefright/CameraSource.cpp              |  24 +-
 media/libstagefright/DataSource.cpp                |  22 +-
 media/libstagefright/MPEG4Extractor.cpp            |  38 +-
 media/libstagefright/MPEG4Writer.cpp               |   5 +
 media/libstagefright/MediaDefs.cpp                 |   6 +
 media/libstagefright/MediaExtractor.cpp            |  11 +
 media/libstagefright/NuCachedFileSource2.cpp       | 735 ++++++++++++++++++
 media/libstagefright/OMXCodec.cpp                  | 135 ++++
 media/libstagefright/PCMExtractor.cpp              | 302 ++++++++
 media/libstagefright/SampleTable.cpp               |   5 +-
 .../StagefrightMetadataRetriever.cpp               |  55 +-
 media/libstagefright/SurfaceMediaSource.cpp        |  20 +-
 .../colorconversion/ColorConverter.cpp             | 148 +++-
 media/libstagefright/foundation/ABitReader.cpp     |  15 +
 media/libstagefright/include/ASFExtractor.h        | 142 ++++
 media/libstagefright/include/AVIExtractor.h        |   6 +
 media/libstagefright/include/NuCachedFileSource2.h | 149 ++++
 media/libstagefright/include/PCMExtractor.h        |  61 ++
 media/libstagefright/include/SampleTable.h         |   2 +-
 media/libstagefright/include/asf.h                 | 303 ++++++++
 media/libstagefright/include/asfint.h              | 141 ++++
 media/libstagefright/include/byteio.h              |  27 +
 media/libstagefright/include/compat.h              |  60 ++
 media/libstagefright/include/data.h                |  28 +
 media/libstagefright/include/debug.h               |  45 ++
 media/libstagefright/include/guid.h                |  69 ++
 media/libstagefright/include/header.h              |  29 +
 media/libstagefright/include/parse.h               |  29 +
 media/libstagefright/include/utf.h                 | 110 +++
 media/libstagefright/mpeg2ts/ESQueue.cpp           |  19 +-
 media/libstagefright/mpeg2ts/ESQueue.h             |   8 +
 media/libstagefright/omx/SoftOMXPlugin.cpp         |   5 +
 media/libstagefright/rtsp/AMPEG4AudioAssembler.cpp |  77 +-
 media/libstagefright/tests/Android.mk              |   2 +
 52 files changed, 4064 insertions(+), 77 deletions(-)
 create mode 100644 media/libstagefright/ASFExtractor.cpp
 create mode 100644 media/libstagefright/NuCachedFileSource2.cpp
 create mode 100644 media/libstagefright/PCMExtractor.cpp
 create mode 100644 media/libstagefright/include/ASFExtractor.h
 create mode 100644 media/libstagefright/include/NuCachedFileSource2.h
 create mode 100644 media/libstagefright/include/PCMExtractor.h
 create mode 100644 media/libstagefright/include/asf.h
 create mode 100644 media/libstagefright/include/asfint.h
 create mode 100644 media/libstagefright/include/byteio.h
 create mode 100644 media/libstagefright/include/compat.h
 create mode 100644 media/libstagefright/include/data.h
 create mode 100644 media/libstagefright/include/debug.h
 create mode 100644 media/libstagefright/include/guid.h
 create mode 100644 media/libstagefright/include/header.h
 create mode 100644 media/libstagefright/include/parse.h
 create mode 100644 media/libstagefright/include/utf.h

diff --git a/camera/CameraParameters.cpp b/camera/CameraParameters.cpp
index 31be59d..df9af01 100644
--- a/camera/CameraParameters.cpp
+++ b/camera/CameraParameters.cpp
@@ -342,6 +342,13 @@ const char CameraParameters::SCENE_MODE_FIREWORKS[] = "fireworks";
 const char CameraParameters::SCENE_MODE_SPORTS[] = "sports";
 const char CameraParameters::SCENE_MODE_PARTY[] = "party";
 const char CameraParameters::SCENE_MODE_CANDLELIGHT[] = "candlelight";
+#ifdef STE_SAMSUNG_HARDWARE
+const char CameraParameters::SCENE_MODE_AQUA[] = "aqua";
+const char CameraParameters::SCENE_MODE_BACKLIGHT[] = "backlight";
+const char CameraParameters::SCENE_MODE_DUSKDAWN[] = "duskdawn";
+const char CameraParameters::SCENE_MODE_FALLCOLOR[] = "fallcolor";
+const char CameraParameters::SCENE_MODE_TEXT[] = "text";
+#endif
 #ifdef QCOM_HARDWARE
 #ifdef SAMSUNG_CAMERA_LEGACY
 const char CameraParameters::SCENE_MODE_BACKLIGHT[] = "back-light";
@@ -376,6 +383,16 @@ const char CameraParameters::PIXEL_FORMAT_JPEG[] = "jpeg";
 const char CameraParameters::PIXEL_FORMAT_BAYER_RGGB[] = "bayer-rggb";
 const char CameraParameters::PIXEL_FORMAT_ANDROID_OPAQUE[] = "android-opaque";
 
+#ifdef STE_HARDWARE
+const char CameraParameters::PIXEL_FORMAT_YUV420SPNV12[] = "yuv420spnv12";
+const char CameraParameters::PIXEL_FORMAT_YUV420MB[] = "yuv420mb";
+const char CameraParameters::PIXEL_FORMAT_YVU422SP[] = "yvu422sp";
+const char CameraParameters::PIXEL_FORMAT_YVU422P[] = "yvu422p";
+const char CameraParameters::PIXEL_FORMAT_YVU420SP[] = "yvu420sp";
+const char CameraParameters::PIXEL_FORMAT_YVU420P[]  = "yvu420p";
+const char CameraParameters::PIXEL_FORMAT_UYV422I[] = "yuv422i-uyvy";
+#endif
+
 #ifdef QCOM_HARDWARE
 const char CameraParameters::PIXEL_FORMAT_RAW[] = "raw";
 const char CameraParameters::PIXEL_FORMAT_YV12[] = "yuv420p";
@@ -536,6 +553,12 @@ const char CameraParameters::LIGHTFX_HDR[] = "high-dynamic-range";
 CAMERA_PARAMETERS_EXTRA_C
 #endif
 
+#ifdef STE_HARDWARE
+// keys for record stride and sliceheight
+const char CameraParameters::KEY_RECORD_STRIDE[] = "record-stride";
+const char CameraParameters::KEY_RECORD_SLICE_HEIGHT[] = "record-slice-height";
+#endif
+
 CameraParameters::CameraParameters()
                 : mMap()
 {
diff --git a/cmds/stagefright/recordvideo.cpp b/cmds/stagefright/recordvideo.cpp
index c30c122..bfe1259 100644
--- a/cmds/stagefright/recordvideo.cpp
+++ b/cmds/stagefright/recordvideo.cpp
@@ -34,7 +34,7 @@ static void usage(const char *me) {
     fprintf(stderr, "usage: %s\n", me);
     fprintf(stderr, "       -h(elp)\n");
     fprintf(stderr, "       -b bit rate in bits per second (default: 300000)\n");
-    fprintf(stderr, "       -c YUV420 color format: [0] semi planar or [1] planar or other omx YUV420 color format (default: 1)\n");
+    fprintf(stderr, "       -c YUV420 color format: [0] semi planar or [1] planar or [2] MBTiled or other omx YUV420 color format (default: 1)\n");
     fprintf(stderr, "       -f frame rate in frames per second (default: 30)\n");
     fprintf(stderr, "       -i I frame interval in seconds (default: 1)\n");
     fprintf(stderr, "       -n number of frames to be recorded (default: 300)\n");
@@ -43,6 +43,7 @@ static void usage(const char *me) {
     fprintf(stderr, "       -l encoder level. see omx il header (default: encoder specific)\n");
     fprintf(stderr, "       -p encoder profile. see omx il header (default: encoder specific)\n");
     fprintf(stderr, "       -v video codec: [0] AVC [1] M4V [2] H263 (default: 0)\n");
+    fprintf(stderr, "       -y YUV file input (default: NULL)\n");
     fprintf(stderr, "       -s(oftware) prefer software codec\n");
     fprintf(stderr, "       -o filename: output file (default: /sdcard/output.mp4)\n");
     exit(1);
@@ -51,13 +52,14 @@ static void usage(const char *me) {
 class DummySource : public MediaSource {
 
 public:
-    DummySource(int width, int height, int nFrames, int fps, int colorFormat)
+    DummySource(int width, int height, int nFrames, int fps, int colorFormat, int fd)
         : mWidth(width),
           mHeight(height),
           mMaxNumFrames(nFrames),
           mFrameRate(fps),
           mColorFormat(colorFormat),
-          mSize((width * height * 3) / 2) {
+          mSize((width * height * 3) / 2),
+          mFd((FILE*)fd){
 
         mGroup.add_buffer(new MediaBuffer(mSize));
     }
@@ -83,6 +85,7 @@ public:
 
     virtual status_t read(
             MediaBuffer **buffer, const MediaSource::ReadOptions *options) {
+        int bytesCopied = 0;
 
         if (mNumFramesOutput % 10 == 0) {
             fprintf(stderr, ".");
@@ -96,22 +99,40 @@ public:
             return err;
         }
 
+        // Read a YUV frame from the file into the buffer
+        if (mFd != NULL) {
+            bytesCopied = fread((*buffer)->data(), 1, mSize, mFd);
+        }
+
         // We don't care about the contents. we just test video encoder
         // Also, by skipping the content generation, we can return from
         // read() much faster.
         //char x = (char)((double)rand() / RAND_MAX * 255);
         //memset((*buffer)->data(), x, mSize);
-        (*buffer)->set_range(0, mSize);
-        (*buffer)->meta_data()->clear();
-        (*buffer)->meta_data()->setInt64(
-                kKeyTime, (mNumFramesOutput * 1000000) / mFrameRate);
-        ++mNumFramesOutput;
 
-        return OK;
+        if (mFd == NULL || bytesCopied == mSize) {
+            (*buffer)->set_range(0, mSize);
+            (*buffer)->meta_data()->clear();
+            (*buffer)->meta_data()->setInt64(kKeyTime,(mNumFramesOutput * 1000000) / mFrameRate);
+
+            ++mNumFramesOutput;
+            return OK;
+        } else {
+            if (mFd != NULL) {
+                fclose(mFd);
+            }
+            mFd = NULL;
+            return ERROR_END_OF_STREAM;
+        }
     }
 
 protected:
-    virtual ~DummySource() {}
+    virtual ~DummySource() {
+        if (mFd != NULL) {
+            fclose(mFd);
+            mFd = NULL;
+        }
+    }
 
 private:
     MediaBufferGroup mGroup;
@@ -120,7 +141,8 @@ private:
     int mFrameRate;
     int mColorFormat;
     size_t mSize;
-    int64_t mNumFramesOutput;;
+    int64_t mNumFramesOutput;
+    FILE* mFd;
 
     DummySource(const DummySource &);
     DummySource &operator=(const DummySource &);
@@ -129,6 +151,7 @@ private:
 enum {
     kYUV420SP = 0,
     kYUV420P  = 1,
+    kYUV420MB = 2, // STE proprietary color format
 };
 
 // returns -1 if mapping of the given color is unsuccessful
@@ -139,6 +162,9 @@ static int translateColorToOmxEnumValue(int color) {
             return OMX_COLOR_FormatYUV420SemiPlanar;
         case kYUV420P:
             return OMX_COLOR_FormatYUV420Planar;
+        case kYUV420MB:
+            // STE proprietory color format
+            return OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB;
         default:
             fprintf(stderr, "Custom OMX color format: %d\n", color);
             if (color == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar ||
@@ -162,12 +188,13 @@ int main(int argc, char **argv) {
     int level = -1;        // Encoder specific default
     int profile = -1;      // Encoder specific default
     int codec = 0;
+    FILE *fd = NULL;
     char *fileName = "/sdcard/output.mp4";
     bool preferSoftwareCodec = false;
 
     android::ProcessState::self()->startThreadPool();
     int res;
-    while ((res = getopt(argc, argv, "b:c:f:i:n:w:t:l:p:v:o:hs")) >= 0) {
+    while ((res = getopt(argc, argv, "b:c:f:i:n:w:t:l:p:v:y:h")) >= 0) {
         switch (res) {
             case 'b':
             {
@@ -247,6 +274,16 @@ int main(int argc, char **argv) {
                 break;
             }
 
+            case 'y':
+            {
+                fd = fopen(optarg,"rb");
+                if (fd == NULL) {
+                    fprintf(stderr, "Error: Unable to open the file\n");
+                    return -1;
+                }
+            }
+            break;
+
             case 'h':
             default:
             {
@@ -261,7 +298,7 @@ int main(int argc, char **argv) {
 
     status_t err = OK;
     sp<MediaSource> source =
-        new DummySource(width, height, nFrames, frameRateFps, colorFormat);
+        new DummySource(width, height, nFrames, frameRateFps, colorFormat, (int)fd);
 
     sp<MetaData> enc_meta = new MetaData;
     switch (codec) {
diff --git a/include/camera/CameraParameters.h b/include/camera/CameraParameters.h
index a5d9c65..e4ff224 100644
--- a/include/camera/CameraParameters.h
+++ b/include/camera/CameraParameters.h
@@ -857,6 +857,13 @@ public:
     static const char SCENE_MODE_SPORTS[];
     static const char SCENE_MODE_PARTY[];
     static const char SCENE_MODE_CANDLELIGHT[];
+#ifdef STE_SAMSUNG_HARDWARE
+    static const char SCENE_MODE_AQUA[];
+    static const char SCENE_MODE_BACKLIGHT[];
+    static const char SCENE_MODE_DUSKDAWN[];
+    static const char SCENE_MODE_FALLCOLOR[];
+    static const char SCENE_MODE_TEXT[];
+#endif
 #ifdef QCOM_HARDWARE
     static const char SCENE_MODE_BACKLIGHT[];
     static const char SCENE_MODE_FLOWERS[];
@@ -881,6 +888,16 @@ public:
 #ifdef QCOM_HARDWARE
     static const char PIXEL_FORMAT_YUV420SP_ADRENO[]; // ADRENO
 #endif
+#ifdef STE_HARDWARE
+    static const char PIXEL_FORMAT_YUV420SPNV12[]; // NV12
+    static const char PIXEL_FORMAT_YVU422SP[];
+    static const char PIXEL_FORMAT_YVU422P[];
+    static const char PIXEL_FORMAT_YVU420SP[];
+    static const char PIXEL_FORMAT_YVU420P[];
+    static const char PIXEL_FORMAT_YUV420MB[];
+    static const char PIXEL_FORMAT_UYV422I[];
+#endif
+
     static const char PIXEL_FORMAT_YUV422I[]; // YUY2
     static const char PIXEL_FORMAT_YUV420P[]; // YV12
     static const char PIXEL_FORMAT_RGB565[];
@@ -1087,6 +1104,12 @@ public:
 CAMERA_PARAMETERS_EXTRA_H
 #endif
 
+#ifdef STE_HARDWARE
+    // keys for record stride and slice height
+    static const char KEY_RECORD_STRIDE[];
+    static const char KEY_RECORD_SLICE_HEIGHT[];
+#endif
+
 private:
     DefaultKeyedVector<String8,String8>    mMap;
 };
diff --git a/include/media/stagefright/ColorConverter.h b/include/media/stagefright/ColorConverter.h
index f286708..a6975e6 100644
--- a/include/media/stagefright/ColorConverter.h
+++ b/include/media/stagefright/ColorConverter.h
@@ -85,6 +85,11 @@ private:
     status_t convertQCOMYUV420SemiPlanar(
             const BitmapParams &src, const BitmapParams &dst);
 
+#ifdef STE_HARDWARE
+    status_t convertSTEYUV420PackedSemiPlanarMB(
+            const BitmapParams &src, const BitmapParams &dst);
+#endif
+
     status_t convertYUV420SemiPlanar(
             const BitmapParams &src, const BitmapParams &dst);
 
diff --git a/include/media/stagefright/DataSource.h b/include/media/stagefright/DataSource.h
index 24ca89d..2c168e2 100644
--- a/include/media/stagefright/DataSource.h
+++ b/include/media/stagefright/DataSource.h
@@ -127,6 +127,9 @@ public:
         return String8();
     }
 
+    void setCharUri(const char* uri);
+    const char* getCharUri();
+
     virtual String8 getMIMEType() const;
 
 protected:
@@ -138,6 +141,8 @@ protected:
 
     DataSource(const DataSource &);
     DataSource &operator=(const DataSource &);
+
+    String8 mUri;
 };
 
 }  // namespace android
diff --git a/include/media/stagefright/MediaDefs.h b/include/media/stagefright/MediaDefs.h
index 481972c..a89bb55 100644
--- a/include/media/stagefright/MediaDefs.h
+++ b/include/media/stagefright/MediaDefs.h
@@ -27,8 +27,14 @@ extern const char *MEDIA_MIMETYPE_VIDEO_VP9;
 extern const char *MEDIA_MIMETYPE_VIDEO_AVC;
 extern const char *MEDIA_MIMETYPE_VIDEO_MPEG4;
 extern const char *MEDIA_MIMETYPE_VIDEO_H263;
+#ifdef STE_HARDWARE
+extern const char *MEDIA_MIMETYPE_VIDEO_H263_SW;
+#endif
 extern const char *MEDIA_MIMETYPE_VIDEO_MPEG2;
 extern const char *MEDIA_MIMETYPE_VIDEO_RAW;
+#ifdef STE_HARDWARE
+extern const char *MEDIA_MIMETYPE_VIDEO_VC1;
+#endif
 
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_NB;
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_WB;
@@ -39,6 +45,7 @@ extern const char *MEDIA_MIMETYPE_AUDIO_MPEG;           // layer III
 extern const char *MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_I;
 extern const char *MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II;
 extern const char *MEDIA_MIMETYPE_AUDIO_AAC;
+extern const char *MEDIA_MIMETYPE_AUDIO_AAC_ELD;
 extern const char *MEDIA_MIMETYPE_AUDIO_QCELP;
 extern const char *MEDIA_MIMETYPE_AUDIO_VORBIS;
 extern const char *MEDIA_MIMETYPE_AUDIO_G711_ALAW;
@@ -59,6 +66,7 @@ extern const char *MEDIA_MIMETYPE_CONTAINER_AVI;
 extern const char *MEDIA_MIMETYPE_CONTAINER_MPEG2PS;
 
 extern const char *MEDIA_MIMETYPE_CONTAINER_WVM;
+extern const char *MEDIA_MIMETYPE_CONTAINER_ASF;
 
 extern const char *MEDIA_MIMETYPE_TEXT_3GPP;
 extern const char *MEDIA_MIMETYPE_TEXT_SUBRIP;
diff --git a/include/media/stagefright/MediaErrors.h b/include/media/stagefright/MediaErrors.h
index 686f286..a98fafc 100644
--- a/include/media/stagefright/MediaErrors.h
+++ b/include/media/stagefright/MediaErrors.h
@@ -63,7 +63,13 @@ enum {
 
     // Heartbeat Error Codes
     HEARTBEAT_ERROR_BASE = -3000,
-    ERROR_HEARTBEAT_TERMINATE_REQUESTED                     = HEARTBEAT_ERROR_BASE,
+    ERROR_HEARTBEAT_AUTHENTICATION_FAILURE                  = HEARTBEAT_ERROR_BASE,
+    ERROR_HEARTBEAT_NO_ACTIVE_PURCHASE_AGREEMENT            = HEARTBEAT_ERROR_BASE - 1,
+    ERROR_HEARTBEAT_CONCURRENT_PLAYBACK                     = HEARTBEAT_ERROR_BASE - 2,
+    ERROR_HEARTBEAT_UNUSUAL_ACTIVITY                        = HEARTBEAT_ERROR_BASE - 3,
+    ERROR_HEARTBEAT_STREAMING_UNAVAILABLE                   = HEARTBEAT_ERROR_BASE - 4,
+    ERROR_HEARTBEAT_CANNOT_ACTIVATE_RENTAL                  = HEARTBEAT_ERROR_BASE - 5,
+    ERROR_HEARTBEAT_TERMINATE_REQUESTED                     = HEARTBEAT_ERROR_BASE - 6,
 };
 
 }  // namespace android
diff --git a/include/media/stagefright/MetaData.h b/include/media/stagefright/MetaData.h
index fbdc301..4c72a73 100644
--- a/include/media/stagefright/MetaData.h
+++ b/include/media/stagefright/MetaData.h
@@ -179,7 +179,13 @@ enum {
     kKeyCryptoKey         = 'cryK',  // uint8_t[16]
     kKeyCryptoIV          = 'cryI',  // uint8_t[16]
     kKeyCryptoMode        = 'cryM',  // int32_t
+#ifdef STE_HARDWARE
+    // To store the extracted metadata in VC1 streams
+    kKeyVC1Info = 'info',  //raw data
 
+    // To store the extracted metadata in WMA streams
+    kKeyWMAInfo = 'wmai', //raw data
+#endif
     kKeyCryptoDefaultIVSize = 'cryS',  // int32_t
 
     kKeyPssh              = 'pssh',  // raw data
@@ -194,6 +200,10 @@ enum {
     kTypeESDS        = 'esds',
     kTypeAVCC        = 'avcc',
     kTypeD263        = 'd263',
+#ifdef STE_HARDWARE
+    kTypeVC1         = 'wmv3',
+    kTypeWMA         = 'wmau',
+#endif
 };
 
 enum {
@@ -204,7 +214,9 @@ enum {
 };
 
 enum {
+#ifndef STE_HARDWARE
     kTypeWMA,
+#endif
     kTypeWMAPro,
     kTypeWMALossLess,
 };
diff --git a/include/media/stagefright/OMXCodec.h b/include/media/stagefright/OMXCodec.h
index 5dd99eb..42eebd8 100644
--- a/include/media/stagefright/OMXCodec.h
+++ b/include/media/stagefright/OMXCodec.h
@@ -93,6 +93,8 @@ struct OMXCodec : public MediaSource,
     // from MediaBufferObserver
     virtual void signalBufferReturned(MediaBuffer *buffer);
 
+    static uint32_t OmxToHALFormat(OMX_COLOR_FORMATTYPE omxValue);
+
     enum Quirks {
         kNeedsFlushBeforeDisable              = 1,
         kWantsNALFragments                    = 2,
@@ -107,6 +109,10 @@ struct OMXCodec : public MediaSource,
         kSupportsMultipleFramesPerInputBuffer = 1024,
         kRequiresLargerEncoderOutputBuffer    = 2048,
         kOutputBuffersAreUnreadable           = 4096,
+#ifdef STE_HARDWARE
+        kRequiresStoreMetaDataBeforeIdle      = 16384,
+        kOverrideDefaultAVCProfile            = 32768,
+#endif
 #ifdef MTK_HARDWARE
         kAvoidMemcopyInputRecordingFrames     = 8192,
 #endif
@@ -409,6 +415,8 @@ private:
     status_t parseAVCCodecSpecificData(
             const void *data, size_t size,
             unsigned *profile, unsigned *level);
+    status_t parseVC1CodecSpecificData(
+            const void *data, size_t size);
 
     status_t stopOmxComponent_l();
     status_t flushBuffersOnError();
diff --git a/include/media/stagefright/SurfaceMediaSource.h b/include/media/stagefright/SurfaceMediaSource.h
index 48b2dd4..16c394e 100644
--- a/include/media/stagefright/SurfaceMediaSource.h
+++ b/include/media/stagefright/SurfaceMediaSource.h
@@ -24,6 +24,7 @@
 #include <utils/Vector.h>
 #include <media/stagefright/MediaSource.h>
 #include <media/stagefright/MediaBuffer.h>
+#include <hardware/copybit.h>
 
 namespace android {
 // ----------------------------------------------------------------------------
@@ -58,7 +59,8 @@ class SurfaceMediaSource : public MediaSource,
                                 public MediaBufferObserver,
                                 protected ConsumerListener {
 public:
-    enum { MIN_UNDEQUEUED_BUFFERS = 4};
+    enum { MIN_UNDEQUEUED_BUFFERS = 4,
+           MAX_UNDEQUEUED_BUFFERS = 10 };
 
     struct FrameAvailableListener : public virtual RefBase {
         // onFrameAvailable() is called from queueBuffer() is the FIFO is
@@ -182,6 +184,10 @@ private:
     Vector<MediaBuffer *> mPendingBuffers;
 #endif
 
+    // mCurrentBuffersDQ is used to free buffers of mBufferSlot. This is used
+    // only when conversion takes place.
+    Vector<sp<GraphicBuffer> > mCurrentBuffersDQ;
+
     // mCurrentTimestamp is the timestamp for the current texture. It
     // gets set to mLastQueuedTimestamp each time updateTexImage is called.
     int64_t mCurrentTimestamp;
@@ -231,6 +237,30 @@ private:
 
     // Avoid copying and equating and default constructor
     DISALLOW_IMPLICIT_CONSTRUCTORS(SurfaceMediaSource);
+
+    // mGraphicBufferAlloc is the connection to SurfaceFlinger that is used to
+    // allocate new GraphicBuffer objects.
+    sp<IGraphicBufferAlloc> mGraphicBufferAlloc;
+
+    // HAL pixel format for yuv buffer
+    int mYuvPixelFormat;
+
+    // Set true when read called for first time
+    // Used to avoid setting of 'mStopped' Flag in onBuffersReleased when
+    // setBufferCount is called for first time
+    bool mIsReading;
+
+    sp<GraphicBuffer> mGraphicBufferYuv[MAX_UNDEQUEUED_BUFFERS];
+
+    // returns TRUE if buffer needs color format conversion
+    bool conversionIsNeeded(const sp<GraphicBuffer>& graphicBuffer);
+
+    // converts buffer to a suitable color format
+    status_t convert(const sp<GraphicBuffer> &srcBuf, const sp<GraphicBuffer> &dstBuf);
+
+    // mBlitEngine is the handle to the copybit device which will be used in
+    // case color transform is needed before the buffer is sent to encoder.
+    copybit_device_t* mBlitEngine;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/include/media/stagefright/foundation/ABitReader.h b/include/media/stagefright/foundation/ABitReader.h
index 5510b12..bf3967a 100644
--- a/include/media/stagefright/foundation/ABitReader.h
+++ b/include/media/stagefright/foundation/ABitReader.h
@@ -31,6 +31,7 @@ struct ABitReader {
     uint32_t getBits(size_t n);
     void skipBits(size_t n);
 
+    void rewindBits(size_t n);
     void putBits(uint32_t x, size_t n);
 
     size_t numBitsLeft() const;
@@ -39,7 +40,9 @@ struct ABitReader {
 
 private:
     const uint8_t *mData;
+    const uint8_t *mOriginalData;
     size_t mSize;
+    size_t mOriginalSize;
 
     uint32_t mReservoir;  // left-aligned bits
     size_t mNumBitsLeft;
diff --git a/media/libmedia/AudioTrack.cpp b/media/libmedia/AudioTrack.cpp
index 8b97020..0850159 100644
--- a/media/libmedia/AudioTrack.cpp
+++ b/media/libmedia/AudioTrack.cpp
@@ -38,6 +38,8 @@
 #define WAIT_STREAM_END_TIMEOUT_SEC     120
 
 
+#define OBTAIN_BUFFER_WAIT_TIME (70)
+
 namespace android {
 // ---------------------------------------------------------------------------
 
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index 8c4f34e..7e1e860 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -54,6 +54,9 @@
 #include <gui/Surface.h>
 #include <utils/String8.h>
 
+#include <utils/String8.h>
+#include <cutils/properties.h>
+
 #include <utils/Errors.h>
 #include <sys/types.h>
 #include <ctype.h>
@@ -78,6 +81,8 @@
 #define RES_720P (720*1280)
 #define DUR_30MIN (30*60*1000*1000)
 #define DUR_10MIN (10*60*1000*1000)
+#define DEFAULT_VIDEO_ENCODER "ro.default.video.encoder"
+
 namespace android {
 
 // To collect the encoder usage for the battery app
@@ -234,12 +239,19 @@ status_t StagefrightRecorder::setVideoEncoder(video_encoder ve) {
         ALOGE("Invalid video encoder: %d", ve);
         return BAD_VALUE;
     }
+    // Read DEFAULT_VIDEO_ENCODER and set the default video encoder
+    video_encoder defaultEncoder = VIDEO_ENCODER_H263;
+    char value[PROPERTY_VALUE_MAX];
+    property_get(DEFAULT_VIDEO_ENCODER, value, "");
+    if (strncmp(value, "h264", 4) == 0) {
+        defaultEncoder = VIDEO_ENCODER_H264;
+    }
 
     if (ve == VIDEO_ENCODER_DEFAULT) {
 #ifdef MTK_HARDWARE //In order to pass CTS test case for preview size: 320 x 240
         mVideoEncoder = VIDEO_ENCODER_MPEG_4_SP;
 #else
-        mVideoEncoder = VIDEO_ENCODER_H263;
+        mVideoEncoder = defaultEncoder;
 #endif
     } else {
         mVideoEncoder = ve;
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 49ad086..0110ea1 100755
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -655,8 +655,12 @@ status_t ACodec::configureOutputBuffersFromNativeWindow(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
+#ifdef STE_HARDWARE
+	    OMXCodec::OmxToHALFormat(def.format.video.eColorFormat));
+#else
             def.format.video.eColorFormat);
 #endif
+#endif
 
     if (err != 0) {
         ALOGE("native_window_set_buffers_geometry failed: %s (%d)",
@@ -1088,6 +1092,8 @@ status_t ACodec::setComponentRole(
 #endif
         { MEDIA_MIMETYPE_AUDIO_AAC,
             "audio_decoder.aac", "audio_encoder.aac" },
+        { MEDIA_MIMETYPE_AUDIO_AAC_ELD,
+            "audio_decoder.aeld", "audio_encoder.aeld" },
         { MEDIA_MIMETYPE_AUDIO_VORBIS,
             "audio_decoder.vorbis", "audio_encoder.vorbis" },
         { MEDIA_MIMETYPE_AUDIO_G711_MLAW,
@@ -1377,7 +1383,8 @@ status_t ACodec::configureCodec(
                     sampleRate,
                     numChannels);
         }
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)) {
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)
+           || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC_ELD)) {
         int32_t numChannels, sampleRate;
         if (!msg->findInt32("channel-count", &numChannels)
                 || !msg->findInt32("sample-rate", &sampleRate)) {
@@ -1486,6 +1493,12 @@ status_t ACodec::configureCodec(
         err = setMinBufferSize(kPortIndexInput, (size_t)maxInputSize);
     } else if (!strcmp("OMX.Nvidia.aac.decoder", mComponentName.c_str())) {
         err = setMinBufferSize(kPortIndexInput, 8192);  // XXX
+    } else if (!strncasecmp(mime, "video/", 6)) {
+        int32_t width, height;
+        CHECK(msg->findInt32("width", &width));
+        CHECK(msg->findInt32("height", &height));
+
+        err = setMinBufferSize(kPortIndexInput, (size_t)(width * height));
     }
 
     return err;
diff --git a/media/libstagefright/ASFExtractor.cpp b/media/libstagefright/ASFExtractor.cpp
new file mode 100644
index 0000000..2c7221f
--- /dev/null
+++ b/media/libstagefright/ASFExtractor.cpp
@@ -0,0 +1,853 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "ASFExtractor"
+#include <utils/Log.h>
+#include <stdio.h>
+
+#include <binder/ProcessState.h>
+#include <media/stagefright/foundation/hexdump.h>
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/MediaBuffer.h>
+#include <media/stagefright/MediaBufferGroup.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/Utils.h>
+
+#include "include/ASFExtractor.h"
+#include "include/asfint.h"
+#include <dlfcn.h>
+
+static int32_t asfFileioReadCbSf(void *iostream,  void *buffer, int32_t size);
+static int64_t asfFileioSeekCbSf(void *asf_file, int64_t requiredBitStreamPostion);
+
+namespace android {
+
+static const int32_t kSizeOfVC1Info = 20;
+static const int32_t kSizeOfBitmapInfoHeader = 40;
+static const int32_t kSizeOfWaveFormatEx = 18;
+static const int32_t kSizeOfFrameHeader = 4;
+
+struct ASFExtractor::ASFSource : public MediaSource {
+    ASFSource(const sp<ASFExtractor> &extractor, size_t trackIndex);
+
+    virtual status_t start(MetaData *params);
+    virtual status_t stop();
+
+    virtual sp<MetaData> getFormat();
+
+    virtual status_t read(
+            MediaBuffer **buffer, const ReadOptions *options);
+
+protected:
+    virtual ~ASFSource();
+
+private:
+    status_t getFirstPacket();
+    status_t seekToClosestPosition(int64_t seekTimeUs, MediaSource::ReadOptions::SeekMode mode);
+
+    sp<ASFExtractor> mExtractor;
+    size_t mTrackIndex;
+    const ASFExtractor::Track &mTrack;
+    MediaBufferGroup *mBufferGroup;
+    size_t mSampleIndex;
+    asf_stream_type_t mStreamNum;
+    int32_t mPayloadIndex;
+    bool mEndOfStream;
+    bool mIsFirstPacket;
+    int64_t mTrackTimeStamp;
+    int64_t mLastFilePosition;
+    asf_packet_t *mPacket;
+    int64_t mAccumalatedSize;
+    TrackTypes mStreamType;
+
+    DISALLOW_EVIL_CONSTRUCTORS(ASFSource);
+};
+
+ASFExtractor::ASFSource::ASFSource(
+    const sp<ASFExtractor> &extractor, size_t trackIndex)
+    : mExtractor(extractor),
+      mTrackIndex(trackIndex),
+      mTrack(mExtractor->mTracks.itemAt(trackIndex)),
+      mBufferGroup(NULL) {
+    mStreamNum = mTrack.mStreamNumber;
+    if (mTrack.mKind == Track::AUDIO) {
+        mStreamType = AUDIO_TRACK;
+    } else if (mTrack.mKind == Track::VIDEO) {
+        mStreamType = VIDEO_TRACK;
+    }
+
+    mPayloadIndex = 0;
+    mEndOfStream = false;
+    mIsFirstPacket = true;
+    mTrackTimeStamp = 0;
+    mLastFilePosition = 0;
+    mAccumalatedSize = 0;
+    mPacket = NULL;
+    mPacket = (*(mExtractor->libasf_packet_create))();
+}
+
+ASFExtractor::ASFSource::~ASFSource() {
+    if (mBufferGroup) {
+        stop();
+    }
+
+    if (NULL != mPacket) {
+        (*(mExtractor->libasf_packet_destroy))(mPacket);
+    }
+}
+
+status_t ASFExtractor::ASFSource::start(MetaData *params) {
+    CHECK(!mBufferGroup);
+
+    mBufferGroup = new MediaBufferGroup;
+    mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxSampleSize));
+    mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxSampleSize));
+    mSampleIndex = 0;
+
+    const char *mime;
+    CHECK(mTrack.mMeta->findCString(kKeyMIMEType, &mime));
+    return OK;
+}
+
+status_t ASFExtractor::ASFSource::stop() {
+    CHECK(mBufferGroup);
+
+    delete mBufferGroup;
+    mBufferGroup = NULL;
+    return OK;
+}
+
+sp<MetaData> ASFExtractor::ASFSource::getFormat() {
+    return mTrack.mMeta;
+}
+
+////////////////////////////////////////////////////////
+// Read the packet from the stream when read() is called
+// for the first time
+status_t ASFExtractor::ASFSource::getFirstPacket() {
+    status_t err;
+
+    // Retrieve the first packet for the specific Track
+    do {
+        // Read the packet from the current file position
+        err = mExtractor->getPacket(mExtractor->mFileHandle, this->mPacket);
+        if (err != OK) {
+            return ERROR_END_OF_STREAM;
+        }
+
+        // Search for the specific payload within the Data Packet
+        for (int32_t i = 0; i < this->mPacket->payload_count; i++) {
+            if (this->mPacket->payloads[i].stream_number == this->mStreamNum
+                                                     && this->mIsFirstPacket) {
+                this->mIsFirstPacket = false;
+                this->mPayloadIndex = i;
+            }
+        }
+
+    } while (this->mIsFirstPacket);
+
+    return OK;
+}
+
+//////////////////////////////////////////////////////////
+// This implementation handles 3 different seek modes and
+// SEEK_CLOSEST_SYNC is the default
+status_t ASFExtractor::ASFSource::seekToClosestPosition
+            (int64_t seekTimeUs, MediaSource::ReadOptions::SeekMode mode) {
+    status_t err;
+    int32_t  prevKeyIdx;
+    int64_t  prevKeyDataPosition;
+    int64_t  prevKeytimeUs;
+    int32_t  nextKeyIdx;
+    bool     isPrevKeyFound, isNextKeyFound;
+    int64_t  nextKeyDataPosition;
+    int64_t  nextKeytimeUs;
+    int64_t  finalKeytimeUs;
+    int64_t  currentOffsetPosn;
+    int64_t  finalOffsetPosn;
+    int32_t  finalKeyIdx;
+    bool     iskeyCheckNotRequired = false;
+
+    // Initializations
+    prevKeyIdx = nextKeyIdx = 0;
+    prevKeyDataPosition = nextKeyDataPosition = mExtractor->mFileHandle->iostream.bit_stream_position;
+    prevKeytimeUs = nextKeytimeUs = finalKeytimeUs = seekTimeUs;
+    isPrevKeyFound = isNextKeyFound = false;
+    finalOffsetPosn = mExtractor->mFileHandle->iostream.bit_stream_position;
+    finalKeyIdx = 0;
+
+    ALOGV("ASFSource::seekToClosestPosition: ENTRY");
+    if (mStreamType == AUDIO_TRACK) {
+        iskeyCheckNotRequired = true;
+    }
+
+    // Retrieve the first packet for the specific Track
+    do {
+        // Read the current offset position inside the file
+        currentOffsetPosn = mExtractor->mFileHandle->iostream.bit_stream_position;
+
+        // Read the packet from the current file position
+        err = mExtractor->getPacket(mExtractor->mFileHandle, this->mPacket);
+        if (err != OK) {
+            break;
+        }
+
+        // Search for the specific payload within the Data Packet
+        for (int32_t i = 0; i < this->mPacket->payload_count; i++) {
+            if (this->mPacket->payloads[i].stream_number == this->mStreamNum &&
+                    (this->mPacket->payloads[i].key_frame || iskeyCheckNotRequired)) {
+                if (this->mPacket->payloads[i].pts * 1000 != prevKeytimeUs &&
+                        this->mPacket->payloads[i].pts * 1000 <= seekTimeUs) {
+                    // Case when the timestamp of the key frame is
+                    // less than or equal to desired timestamp
+                    prevKeyIdx = i;
+                    prevKeyDataPosition = currentOffsetPosn;
+                    prevKeytimeUs = this->mPacket->payloads[i].pts;
+                    isPrevKeyFound = true;
+                    ALOGV("Prev Sync TimeStamp: %lld, prevKeyDataPosition: %lld",
+                            prevKeytimeUs, prevKeyDataPosition);
+                } else {
+                    // Case when the timestamp is greater than requested time stamp
+                    if (!isNextKeyFound) {
+                        nextKeyIdx = i;
+                        nextKeyDataPosition = currentOffsetPosn;
+                        nextKeytimeUs = this->mPacket->payloads[i].pts;
+                        isNextKeyFound = true;
+                        ALOGV("Next Sync TimeStamp: %lld, nextKeyDataPosition: %lld",
+                                nextKeytimeUs, nextKeyDataPosition);
+                    }
+                }
+            }
+        }
+    } while (!isNextKeyFound);
+
+    if (!isNextKeyFound && !isPrevKeyFound) {
+        return ERROR_END_OF_STREAM;
+    } else if (!isNextKeyFound && isPrevKeyFound) {
+        finalOffsetPosn = prevKeyDataPosition;
+        finalKeyIdx = prevKeyIdx;
+        finalKeytimeUs  = prevKeytimeUs;
+    } else {
+
+        // The timestamps of the previous and next key frames are available
+        // The parser has to decide between the 2 timestamps
+        switch (mode) {
+            case MediaSource::ReadOptions::SEEK_CLOSEST_SYNC:
+                ALOGV("SEEK_CLOSEST_SYNC");
+                if (seekTimeUs - prevKeytimeUs < nextKeytimeUs - seekTimeUs) {
+                    if (isPrevKeyFound) {
+                        finalOffsetPosn = prevKeyDataPosition;
+                        finalKeyIdx     = prevKeyIdx;
+                        finalKeytimeUs  = prevKeytimeUs;
+                    }
+                } else {
+                    if (isNextKeyFound) {
+                        finalOffsetPosn = nextKeyDataPosition;
+                        finalKeyIdx     = nextKeyIdx;
+                        finalKeytimeUs  = nextKeytimeUs;
+                    }
+                }
+            break;
+
+            case MediaSource::ReadOptions::SEEK_PREVIOUS_SYNC:
+                ALOGV("SEEK_PREVIOUS_SYNC");
+                if (isPrevKeyFound) {
+                    finalOffsetPosn = prevKeyDataPosition;
+                    finalKeyIdx     = prevKeyIdx;
+                    finalKeytimeUs  = prevKeytimeUs;
+                }
+            break;
+
+            case MediaSource::ReadOptions::SEEK_NEXT_SYNC:
+                ALOGV("SEEK_NEXT_SYNC");
+                if (isNextKeyFound) {
+                    finalOffsetPosn = nextKeyDataPosition;
+                    finalKeyIdx     = nextKeyIdx;
+                    finalKeytimeUs  = nextKeytimeUs;
+                }
+            break;
+
+            default:
+                ALOGV("Default Case");
+                if (seekTimeUs - prevKeytimeUs < nextKeytimeUs - seekTimeUs) {
+                    if (isPrevKeyFound) {
+                        finalOffsetPosn = prevKeyDataPosition;
+                        finalKeyIdx     = prevKeyIdx;
+                        finalKeytimeUs  = prevKeytimeUs;
+                    }
+                } else {
+                    if (isNextKeyFound) {
+                        finalOffsetPosn = nextKeyDataPosition;
+                        finalKeyIdx     = nextKeyIdx;
+                        finalKeytimeUs  = nextKeytimeUs;
+                    }
+                }
+            break;
+        }
+    }
+
+    // Decide on finalOffsetPosn, finalKeyIdx
+    this->mLastFilePosition = finalOffsetPosn;
+
+    // Seek to appropriate packet and set the index
+    mExtractor->mFileHandle->iostream.seek(mExtractor->mFileHandle, this->mLastFilePosition);
+    this->mPayloadIndex = finalKeyIdx;
+    this->mTrackTimeStamp = finalKeytimeUs;
+    ALOGV("finalOffsetPosn: %lld, finalKeyIdx: %d, finalKeytimeUs: %lld",
+            finalOffsetPosn, finalKeyIdx, finalKeytimeUs);
+    err = mExtractor->getPacket(mExtractor->mFileHandle, this->mPacket);
+    if (err != OK) {
+        return ERROR_END_OF_STREAM;
+    }
+
+    ALOGV("ASFSource::seekToClosestPosition: EXIT");
+    return OK;
+}
+
+//////////////////////////////////////////////////////////////////////////
+// Read multiple data packets until we get the complete frame data.
+// Handles different cases based on the fact that the one media frame data
+// can be part of different data packets.
+status_t ASFExtractor::ASFSource::read(
+        MediaBuffer **buffer, const ReadOptions *options) {
+
+    Mutex::Autolock autoLock(mExtractor->mLock);
+    CHECK(mBufferGroup);
+
+    *buffer = NULL;
+
+    int64_t seekTimeUs;
+    int32_t lFrameSize, lKeyFrame;
+    int64_t lCurrPts;
+    status_t err;
+    bool packetFound;
+    ReadOptions::SeekMode seekMode;
+
+    if (this->mEndOfStream) {
+        return ERROR_END_OF_STREAM;
+    }
+
+    // Restore the position for the current track
+    if (this->mIsFirstPacket) {
+        this->mLastFilePosition = mExtractor->mDataPacketPosition;
+    }
+    mExtractor->mFileHandle->iostream.seek(mExtractor->mFileHandle, this->mLastFilePosition);
+
+    if (options && options->getSeekTo(&seekTimeUs, &seekMode)) {
+        // libasf works on mses
+        do {
+            err = mExtractor->getSampleIndexAtTime(mExtractor->mFileHandle, seekTimeUs / 1000);
+            if (err != OK) {
+                seekTimeUs = seekTimeUs - 1000000;
+            }
+        } while (err != OK);
+
+        this->mPayloadIndex = 0;
+        this->mAccumalatedSize = 0;
+
+        err = this->seekToClosestPosition(seekTimeUs, seekMode);
+        if (err != OK) {
+            return err;
+        }
+
+        ALOGV("Seek is successful!!!");
+        this->mIsFirstPacket = false;
+    }
+
+    // Case when the read is called for the very first packet
+    if (this->mIsFirstPacket) {
+        err = this->getFirstPacket();
+        if (err != OK) {
+            return err;
+        }
+    }
+
+    // Read the framesize, current PTS, Key frame status from Data Packet
+    lFrameSize = this->mPacket->payloads[this->mPayloadIndex].media_object_length;
+    lCurrPts = this->mPacket->payloads[this->mPayloadIndex].pts;
+    lKeyFrame = this->mPacket->payloads[this->mPayloadIndex].key_frame;
+    ALOGV("Stream No: %d, lFrameSize: %d, lCurrPts: %lld, lKeyFrame: %d",
+            (int32_t)this->mPacket->payloads[this->mPayloadIndex].stream_number,
+            lFrameSize, lCurrPts, lKeyFrame);
+
+    MediaBuffer *out;
+    CHECK_EQ(mBufferGroup->acquire_buffer(&out), (status_t)OK);
+    uint8_t *framePointer = (uint8_t *)((int32_t)out->data());
+    int32_t frameSize = lFrameSize;
+
+    //Appending Frame Header prior to frame data in case of VC1 Adv profile only
+    if (mExtractor->mIsVC1AdvancedProfile && mStreamType == VIDEO_TRACK) {
+        uint8_t frameHeader[] = {0x00, 0x00, 0x01, 0x0d};
+        memcpy(out->data(), frameHeader, kSizeOfFrameHeader);
+        framePointer = (uint8_t *)out->data() + kSizeOfFrameHeader;
+        frameSize += kSizeOfFrameHeader;
+    }
+    do {
+        // Copy Payload data to Media Buffer
+        for (int32_t i = this->mPayloadIndex; i < this->mPacket->payload_count; i++) {
+            if (this->mPacket->payloads[i].stream_number == this->mStreamNum) {
+                if (this->mPacket->payloads[i].pts != lCurrPts) {
+                    this->mPayloadIndex = i;
+                    out->set_range(0, frameSize);
+                    // Converting to ms to us
+                    out->meta_data()->setInt64(kKeyTime, lCurrPts * 1000);
+                    if (lKeyFrame) {
+                        out->meta_data()->setInt32(kKeyIsSyncFrame, 1);
+                    }
+                    *buffer = out;
+
+                    this->mAccumalatedSize = 0;
+                    this->mTrackTimeStamp = this->mPacket->payloads[this->mPayloadIndex].pts;
+
+                    // Save the file position for the current trackbefore we exit from the loop
+                    this->mLastFilePosition = mExtractor->mFileHandle->iostream.bit_stream_position;
+                    return OK;
+                }
+                memcpy(framePointer + this->mAccumalatedSize,
+                        this->mPacket->payloads[i].data, this->mPacket->payloads[i].datalen);
+                this->mAccumalatedSize += this->mPacket->payloads[i].datalen;
+            }
+        }
+
+        // Read the next payload
+        packetFound = false;
+        do {
+            err = mExtractor->getPacket(mExtractor->mFileHandle, this->mPacket);
+            if (err != OK) {
+                this->mEndOfStream = true;
+                out->release();
+                out = NULL;
+                ALOGV("getPacket is failed in read Implementation, Media Buffer release is done!!!");
+                return ERROR_END_OF_STREAM;
+            }
+
+            for (int32_t i = 0; i < this->mPacket->payload_count; i++) {
+                if (this->mPacket->payloads[i].stream_number == this->mStreamNum &&
+                        !packetFound) {
+                    packetFound = true;
+                    this->mPayloadIndex = i;
+                }
+            }
+        } while (!packetFound);
+    } while (this->mAccumalatedSize < lFrameSize);
+
+    out->set_range(0, frameSize);
+    // Converting to ms to us
+    out->meta_data()->setInt64(kKeyTime, lCurrPts * 1000);
+    if (lKeyFrame) {
+        out->meta_data()->setInt32(kKeyIsSyncFrame, 1);
+    }
+    *buffer = out;
+
+    // Reset the frame statistics
+    this->mAccumalatedSize = 0;
+    // Save the file position for the current trackbefore we exit from the loop
+    this->mLastFilePosition = mExtractor->mFileHandle->iostream.bit_stream_position;
+    ALOGV("EXIT 2: Fragmented Frame Completed for %lld, mLastFilePosition: %lld",
+            lCurrPts, this->mLastFilePosition);
+    return OK;
+}
+
+ASFExtractor::ASFExtractor(const sp<DataSource> &dataSource)
+   : mDataSource(dataSource), mFileHandle(NULL), mIsVC1AdvancedProfile(false){
+     mInitCheck = parseHeaders();
+
+    if (mInitCheck != OK) {
+        mTracks.clear();
+    }
+}
+
+ASFExtractor::~ASFExtractor() {
+    (*libasf_close)(mFileHandle);
+    dlclose(mLibAsfHandle);
+}
+
+size_t ASFExtractor::countTracks() {
+    return mTracks.size();
+}
+
+sp<MediaSource> ASFExtractor::getTrack(size_t index) {
+    return index < mTracks.size() ? new ASFSource(this, index) : NULL;
+}
+
+sp<MetaData> ASFExtractor::getTrackMetaData(
+        size_t index, uint32_t flags) {
+    return index < mTracks.size() ? mTracks.editItemAt(index).mMeta : NULL;
+}
+
+sp<MetaData> ASFExtractor::getMetaData() {
+    sp<MetaData> meta = new MetaData;
+
+    if (mInitCheck == OK) {
+        meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_CONTAINER_ASF);
+    }
+
+    return meta;
+}
+
+int32_t asfFileioReadCbSf(void *iostream, void *buffer, int32_t size) {
+    asf_iostream_t *lIostream;
+
+    // Get the ASF Extractor object
+    lIostream = (asf_iostream_t *)iostream;
+    ASFExtractor *pExtractor = (ASFExtractor *)(lIostream->data_source_handle);
+
+    ssize_t bytesRead = pExtractor->mDataSource->readAt(lIostream->bit_stream_position, buffer, size);
+
+    if (bytesRead < (ssize_t)size) {
+        return ERROR_MALFORMED;
+    }
+    lIostream->bit_stream_position += size;
+    return bytesRead;
+}
+
+int64_t asfFileioSeekCbSf(void *asf_file, int64_t requiredBitStreamPostion) {
+    asf_file_t *lASFFile;
+
+    lASFFile = (asf_file_t *)asf_file;
+    lASFFile->iostream.bit_stream_position = requiredBitStreamPostion;
+    return 0;
+}
+
+asf_file_t* ASFExtractor::asfOpenConfigure() {
+    asf_file_t *file;
+    asf_iostream_t stream;
+
+    stream.read = asfFileioReadCbSf;
+    stream.seek = asfFileioSeekCbSf;
+    stream.write = NULL;
+    stream.opaque = NULL;
+
+    file = asfOpenCb(&stream);
+    if (file == NULL) {
+        return NULL;
+    }
+
+    return file;
+}
+
+asf_file_t* ASFExtractor::asfOpenCb(asf_iostream_t *iostream) {
+    asf_file_t *file;
+    int i;
+    if (iostream == NULL)
+        return NULL;
+
+    file = (asf_file_t *)calloc(1, sizeof(asf_file_t));
+    if (file == NULL) {
+        return NULL;
+    }
+
+    file->filename = NULL;
+    file->iostream.read = iostream->read;
+    file->iostream.write = iostream->write;
+    file->iostream.seek = iostream->seek;
+    file->iostream.opaque = iostream->opaque;
+    file->iostream.bit_stream_position = 0;
+
+    file->header = NULL;
+    file->data = NULL;
+    file->index = NULL;
+
+    for (i = 0; i < ASF_MAX_STREAMS; i++) {
+        file->streams[i].type = ASF_STREAM_TYPE_NONE;
+        file->streams[i].flags = ASF_STREAM_FLAG_NONE;
+        file->streams[i].properties = NULL;
+        file->streams[i].extended_properties = NULL;
+    }
+
+    return file;
+}
+
+/////////////////////////////////////////////////////////////////////
+// This function has implementation of 'dynamic linking' to libasf.so
+// from Android Multimedia Framework.
+// Parse the stream for headers using libasf implementations.
+// Formation of Media Tracks based on stream types and pushing the
+// same into track list.
+// Formation of codec specific data:
+// BITMAPINFOHEADER for VC-1 codec
+// WAVEFORMATEXT for wma codec
+
+status_t ASFExtractor::parseHeaders() {
+    bool isAudioTrackFound = false, isVideoTrackFound = false;
+
+    mLibAsfHandle = dlopen("/system/lib/libasf.so", RTLD_NOW);
+    if (mLibAsfHandle == NULL) {
+        return ERROR_MALFORMED;
+    }
+
+    libasf_init = (asf_init_function)(dlsym(mLibAsfHandle, "asf_init"));
+    if (libasf_init == NULL) {
+        ALOGV("dlopen of libasf.so is failed!!!");
+        return ERROR_MALFORMED;
+    }
+
+    libasf_get_packet = (asf_get_packet_function)(dlsym(mLibAsfHandle, "asf_get_packet"));
+    if (libasf_get_packet == NULL) {
+        return ERROR_MALFORMED;
+    }
+
+    libasf_get_stream = (asf_get_stream_function)(dlsym(mLibAsfHandle, "asf_get_stream"));
+    if (libasf_get_stream == NULL) {
+        return ERROR_MALFORMED;
+    }
+
+    libasf_packet_create = (asf_packet_create_function)(dlsym(mLibAsfHandle, "asf_packet_create"));
+    if (libasf_packet_create == NULL) {
+        return ERROR_MALFORMED;
+    }
+
+    libasf_packet_destroy = (asf_packet_destroy_function)(dlsym(mLibAsfHandle, "asf_packet_destroy"));
+    if (libasf_packet_destroy == NULL) {
+        return ERROR_MALFORMED;
+    }
+
+    libasf_seek_to_msec = (asf_seek_to_msec_function)(dlsym(mLibAsfHandle, "asf_seek_to_msec"));
+    if (libasf_seek_to_msec == NULL) {
+        return ERROR_MALFORMED;
+    }
+    libasf_close = (asf_close_function)(dlsym(mLibAsfHandle, "asf_close"));
+    if (libasf_close == NULL) {
+        return ERROR_MALFORMED;
+    }
+
+    mTracks.clear();
+    mFileHandle = asfOpenConfigure();
+    if (mFileHandle == NULL) {
+        return ERROR_MALFORMED;
+    }
+
+    // Initialize the data handle
+    mFileHandle->iostream.data_source_handle = (int)(this);
+
+    ssize_t res = (*libasf_init)(mFileHandle);
+    if (res < 0) {
+        return ERROR_MALFORMED;
+    }
+
+    ALOGV("Stream Size: %lld", mFileHandle->file_size);
+    asf_stream_t *stream = NULL;
+
+    for (int i = 0; i < ASF_MAX_STREAMS; i++) {
+        stream = (*libasf_get_stream)(mFileHandle, i);
+        if (stream == NULL) {
+            return ERROR_MALFORMED;
+        }
+
+        Track::Kind kind = Track::OTHER;
+
+        if (stream->type == ASF_STREAM_TYPE_AUDIO) {
+            ALOGV("Audio Track Found");
+            sp<MetaData> meta = new MetaData;
+            kind = Track::AUDIO;
+            asf_waveformatex_t *wav = (asf_waveformatex_t *)stream->properties;
+            const char *mime = NULL;
+            mime = MEDIA_MIMETYPE_AUDIO_WMA;
+            meta->setCString(kKeyMIMEType, mime);
+            meta->setInt32(kKeyChannelCount, wav->nChannels);
+            meta->setInt32(kKeySampleRate, wav->nSamplesPerSec);
+            addWMACodecSpecificData(wav, meta);
+            int64_t durationUs;
+            durationUs = mFileHandle->play_duration / 10;
+            ALOGV("Audio Track duration = %.2f secs", durationUs / 1E6);
+            meta->setInt64(kKeyDuration, durationUs);
+            mTracks.push();
+
+            Track *track = &mTracks.editItemAt(mTracks.size() - 1);
+            track->mMeta = meta;
+            track->mKind = kind;
+            track->mNumSyncSamples = 0;
+            track->mThumbnailSampleSize = 0;
+            track->mThumbnailSampleIndex = -1;
+            track->mAvgChunkSize = 1.0;
+            track->mFirstChunkSize = 0;
+            track->mMaxSampleSize = 65536;
+            track->mStreamNumber = (asf_stream_type_t)i;
+            isAudioTrackFound = true;
+        } else if (stream->type == ASF_STREAM_TYPE_VIDEO) {
+            ALOGV("Video Track Found");
+            sp<MetaData> meta = new MetaData;
+            kind = Track::VIDEO;
+            asf_bitmapinfoheader_t *bmp = (asf_bitmapinfoheader_t *)stream->properties;
+            const char *mime = NULL;
+            mime = MEDIA_MIMETYPE_VIDEO_VC1;
+            meta->setCString(kKeyMIMEType, mime);
+            status_t err = addVC1CodecSpecificData(bmp, meta);
+            if (err != OK) {
+                return ERROR_MALFORMED;
+            }
+            int64_t durationUs;
+            durationUs = mFileHandle->play_duration / 10;
+            ALOGE("Track duration = %lld us %.2f secs", durationUs, durationUs / 1E6);
+            meta->setInt64(kKeyDuration, durationUs);
+
+            mTracks.push();
+            Track *track = &mTracks.editItemAt(mTracks.size() - 1);
+            track->mMeta = meta;
+            track->mKind = kind;
+            track->mNumSyncSamples = 0;
+            track->mThumbnailSampleSize = 0;
+            track->mThumbnailSampleIndex = -1;
+
+            if (NULL != stream->extended_properties) {
+                track->mMaxSampleSize = stream->extended_properties->max_obj_size;
+            } else {
+                size_t lInputBufferSize = (bmp->biWidth * bmp->biHeight * 3) >> 1;
+                track->mMaxSampleSize = lInputBufferSize;
+            }
+
+            if (mIsVC1AdvancedProfile) {
+                track->mMaxSampleSize += kSizeOfFrameHeader;
+            }
+
+            track->mAvgChunkSize = 1.0;
+            track->mFirstChunkSize = 0;
+            track->mStreamNumber = (asf_stream_type_t)i;
+            isVideoTrackFound = true;
+        }
+
+        if (isVideoTrackFound && isAudioTrackFound) {
+            break;
+        }
+    }
+
+    mDataPacketPosition = mFileHandle->position;
+    return OK;
+}
+
+status_t ASFExtractor::getSampleIndexAtTime(asf_file_t *fileHandle, int64_t timeUs) {
+    if (NULL == fileHandle) {
+        return ERROR_MALFORMED;
+    }
+
+    status_t err = (*libasf_seek_to_msec)(fileHandle, timeUs);
+    if (err < 0) {
+        ALOGV("ASF file Seek Failed");
+        return ERROR_MALFORMED;
+    }
+
+    return OK;
+}
+
+status_t ASFExtractor::getPacket(asf_file_t *mFileHandle, asf_packet_t *mPacket) {
+    int32_t err;
+    err = (*libasf_get_packet)(mFileHandle, mPacket);
+    if (err < 0) {
+        ALOGV("ASF Get data packet Failed");
+        return ERROR_MALFORMED;
+    }
+
+    return OK;
+}
+
+///////////////////////////////////////////////////////////////////
+// For VC-1 Simple (0x0) and Main Profiles (0x4) populate
+// STRUCT_C(Sc) and STRUCT_A(Sa) information packed as shown below
+// 20 Bytes of header info:
+// 00  00  00  00  00  00  00  00
+// Sc0 Sc1 Sc2 Sc3 Sa0 Sa1 Sa2 Sa3
+// Sa4 Sa5 Sa6 Sa7
+//
+// VC-1 Advanced Profile:
+// If FourCC is WVC1, Concatenating Sequence Header Data and Entry Point Header Data,
+// Passing the same as Codec Specific Data to Underlying decoder
+status_t ASFExtractor::addVC1CodecSpecificData(asf_bitmapinfoheader_t *bmp, sp<MetaData> meta) {
+    uint32_t width, height;
+    uint32_t fourCC = U32_AT((uint8_t *)&bmp->biCompression);
+
+    width  = bmp->biWidth;
+    height = bmp->biHeight;
+    meta->setInt32(kKeyWidth, width);
+    meta->setInt32(kKeyHeight, height);
+
+    // fourCC is WMV3 for VC-1 Simple/Main Profile streams
+    if (fourCC == FOURCC('W', 'M', 'V', '3') || fourCC == FOURCC('w', 'm', 'v', '3')) {
+        ALOGV("VC-1 Simple/Main Profile");
+
+        uint8_t extraData[kSizeOfVC1Info];
+        memset(extraData,0,kSizeOfVC1Info);
+
+        if (bmp->biSize - ASF_BITMAPINFOHEADER_SIZE < 4) {
+            return ERROR_MALFORMED;
+        }
+
+        // Copying 4 bytes of extra data
+        for (int i = 0; i < 4 ; i++) {
+            extraData[i + 8] = bmp->data[i];
+        }
+
+        int32_t height_le = U32LE_AT((uint8_t *)&height);
+        memcpy(&extraData[12], &height_le, 4);
+        int32_t width_le = U32LE_AT((uint8_t *)&width);
+        memcpy(&extraData[16], &width_le, 4);
+
+        meta->setData(kKeyVC1Info, kTypeVC1, extraData, kSizeOfVC1Info);
+    } else if (fourCC == FOURCC('W', 'V', 'C', '1') || fourCC == FOURCC('w', 'v', 'c', '1')) {
+        ALOGV("VC-1 Advanced Profile");
+        mIsVC1AdvancedProfile = true;
+        // Total size of Sequence Header and Entry Point header:
+        // Subtracting 40 bytes of BITMAPINFOHEADER & One byte for ASF Binding byte
+        // from 'Format Data Size'
+        int32_t codecSpecificDataSize = bmp->biSize - kSizeOfBitmapInfoHeader - 1;
+        meta->setData(kKeyVC1Info, kTypeVC1, bmp->data + 1, codecSpecificDataSize);
+    }
+
+    return OK;
+}
+
+////////////////////////////////////////////////////////////////////
+// Formation of codec specific data of wma decoder:
+// Memcpy of bitmapinfoheader fields followed by header info into a
+// single buffer.
+status_t ASFExtractor::addWMACodecSpecificData(asf_waveformatex_t *wav, sp<MetaData> meta) {
+    uint8_t *waveformatex;
+
+    waveformatex = (uint8_t *)malloc(kSizeOfWaveFormatEx + wav->cbSize);
+
+    memcpy(waveformatex, wav, kSizeOfWaveFormatEx);
+    memcpy((waveformatex + kSizeOfWaveFormatEx), wav->data, wav->cbSize);
+
+    meta->setData(kKeyWMAInfo, kTypeWMA, waveformatex, kSizeOfWaveFormatEx + wav->cbSize);
+    free(waveformatex);
+    return OK;
+}
+
+bool SniffASF(
+        const sp<DataSource> &source, String8 *mimeType, float *confidence,
+        sp<AMessage> *) {
+    char tmp[16];
+    // GUID of ASF Header Object
+    char ASF_Header_Object[16] = {0x30, 0x26, 0xb2, 0x75, 0x8e, 0x66, 0xcf, 0x11,
+                                  0xa6, 0xd9, 0x00, 0xaa, 0x00, 0x62, 0xce, 0x6c };
+    if (source->readAt(0, tmp, 16) < 16) {
+        return false;
+    }
+
+    if (!memcmp(tmp, ASF_Header_Object, 16)) {
+        mimeType->setTo(MEDIA_MIMETYPE_CONTAINER_ASF);
+        *confidence = 0.7;
+        return true;
+    }
+
+    return false;
+}
+
+}
diff --git a/media/libstagefright/AVIExtractor.cpp b/media/libstagefright/AVIExtractor.cpp
index 6c384be..bae4f97 100644
--- a/media/libstagefright/AVIExtractor.cpp
+++ b/media/libstagefright/AVIExtractor.cpp
@@ -35,6 +35,12 @@
 
 namespace android {
 
+static const int32_t kSizeOfVC1Info = 20;
+static const int32_t kSizeOfVC1ExtraData = 4;
+static const int32_t kSizeOfBitmapInfoHeader = 40;
+static const int32_t kSizeOfFrameHeader = 4;
+static const uint32_t kVC1FrameHeader = 0x0000010d;
+
 struct AVIExtractor::AVISource : public MediaSource {
     AVISource(const sp<AVIExtractor> &extractor, size_t trackIndex);
 
@@ -182,17 +188,46 @@ status_t AVIExtractor::AVISource::read(
             return ERROR_END_OF_STREAM;
         }
 
+        ssize_t n;
         MediaBuffer *out;
         CHECK_EQ(mBufferGroup->acquire_buffer(&out), (status_t)OK);
-
-        ssize_t n = mExtractor->mDataSource->readAt(offset, out->data(), size);
+        if (!mExtractor->mIsVC1AdvancedProfile) {
+            n = mExtractor->mDataSource->readAt(offset, out->data(), size);
+            out->set_range(0, size);
+        } else {
+            uint8_t frameHeader[] = {0x00, 0x00, 0x01, 0x0d};
+
+            // Define a pointer which is at an offset of frame header size
+            // from the starting of the buffer
+            uint8_t *pData = (uint8_t *)out->data() + kSizeOfFrameHeader;
+
+            // Read the data from the DataSource at the appointed location
+            n = mExtractor->mDataSource->readAt(offset, pData, size);
+
+            // Copy the frameheader to the starting address of the buffer
+            memcpy(out->data(), frameHeader, kSizeOfFrameHeader);
+
+            // Set the appropriate buffer ranges inclusive of frame header size
+            uint32_t startCode;
+            startCode = (pData[0] << 16) | (pData[1] << 8) | pData[2];
+            if (startCode == 0x000001) {
+                uint32_t frameStartCode = 0;
+                int32_t index = 0;
+                while (frameStartCode != kVC1FrameHeader && index < size - 3) {
+                       frameStartCode = (pData[index] << 24) | (pData[index + 1] << 16)
+                                | (pData[index + 2] << 8) | pData[index + 3];
+                       index++;
+                 }
+                 out->set_range(index - 1 + kSizeOfFrameHeader, size - (index - 1));
+            } else {
+                 out->set_range(0, size + kSizeOfFrameHeader);
+            }
+        }
 
         if (n < (ssize_t)size) {
             return n < 0 ? (status_t)n : (status_t)ERROR_MALFORMED;
         }
 
-        out->set_range(0, size);
-
         out->meta_data()->setInt64(kKeyTime, timeUs);
 
         if (isKey) {
@@ -366,7 +401,9 @@ status_t AVIExtractor::MP3Splitter::read(MediaBuffer **out) {
 ////////////////////////////////////////////////////////////////////////////////
 
 AVIExtractor::AVIExtractor(const sp<DataSource> &dataSource)
-    : mDataSource(dataSource) {
+    : mIsVC1SimpleProfile(false),
+      mIsVC1AdvancedProfile(false),
+      mDataSource(dataSource) {
     mInitCheck = parseHeaders();
 
     if (mInitCheck != OK) {
@@ -581,6 +618,12 @@ static const char *GetMIMETypeForHandler(uint32_t handler) {
         case FOURCC('v', 's', 's', 'h'):
             return MEDIA_MIMETYPE_VIDEO_AVC;
 
+        case FOURCC('w', 'm', 'v', '3'):
+        case FOURCC('W', 'M', 'V', '3'):
+        case FOURCC('w', 'v', 'c', '1'):
+        case FOURCC('W', 'V', 'C', '1'):
+            return MEDIA_MIMETYPE_VIDEO_VC1;
+
         default:
             return NULL;
     }
@@ -620,6 +663,17 @@ status_t AVIExtractor::parseStreamHeader(off64_t offset, size_t size) {
 
     if (type == FOURCC('v', 'i', 'd', 's')) {
         mime = GetMIMETypeForHandler(handler);
+        if (mime != NULL && !strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_VC1) &&
+                (handler == FOURCC('w', 'm', 'v', '3') ||
+                handler == FOURCC('W', 'M', 'V', '3'))) {
+            mIsVC1SimpleProfile= true;
+        }
+
+        if (mime != NULL && !strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_VC1) &&
+                (handler == FOURCC('w', 'v', 'c', '1') ||
+                handler == FOURCC('W', 'V', 'C', '1'))) {
+            mIsVC1AdvancedProfile= true;
+        }
 
         if (mime && strncasecmp(mime, "video/", 6)) {
             return ERROR_MALFORMED;
@@ -627,10 +681,10 @@ status_t AVIExtractor::parseStreamHeader(off64_t offset, size_t size) {
 
         if (mime == NULL) {
             ALOGW("Unsupported video format '%c%c%c%c'",
-                 (char)(handler >> 24),
-                 (char)((handler >> 16) & 0xff),
-                 (char)((handler >> 8) & 0xff),
-                 (char)(handler & 0xff));
+                    (char)(handler >> 24),
+                    (char)((handler >> 16) & 0xff),
+                    (char)((handler >> 8) & 0xff),
+                    (char)(handler & 0xff));
         }
 
         kind = Track::VIDEO;
@@ -714,6 +768,33 @@ status_t AVIExtractor::parseStreamFormat(off64_t offset, size_t size) {
         uint32_t width = U32LE_AT(&data[4]);
         uint32_t height = U32LE_AT(&data[8]);
 
+        if (mIsVC1SimpleProfile) {
+            ssize_t s = mDataSource->readAt(offset + kSizeOfBitmapInfoHeader,
+                    track->extraData, kSizeOfVC1ExtraData);
+            if (s < (ssize_t)kSizeOfVC1ExtraData) {
+                return s < 0 ? (status_t)s : ERROR_MALFORMED;
+            }
+        } else if (mIsVC1AdvancedProfile) { // VC1 Advanced Profile
+                // Resync to the start code from 13th Byte as we already consumed 12 bytes
+            uint32_t index = 12;
+            uint32_t startCode = 0;
+
+            while (startCode != 0x00000001 && index < size) {
+                startCode = (data[index] << 16) | (data[index + 1] << 8) | data[index + 2];
+                index++;
+            }
+            // Calculate total size of Sequence Header and Entry Point header
+            // based on strf chunk size
+            uint32_t seqHdrEntryPtHdrSize = size - index + 1;
+            offset += index - 1;
+            track->apExtraData = (uint8_t *)malloc(seqHdrEntryPtHdrSize);
+            track->apExtraDataSize = seqHdrEntryPtHdrSize;
+            ssize_t s = mDataSource->readAt(offset, track->apExtraData, seqHdrEntryPtHdrSize);
+            if (s < (ssize_t)seqHdrEntryPtHdrSize) {
+                return s < 0 ? (status_t)s : ERROR_MALFORMED;
+            }
+        }
+
         track->mMeta->setInt32(kKeyWidth, width);
         track->mMeta->setInt32(kKeyHeight, height);
     } else {
@@ -806,16 +887,18 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
         return ERROR_MALFORMED;
     }
 
-    sp<ABuffer> buffer = new ABuffer(size);
-    ssize_t n = mDataSource->readAt(offset, buffer->data(), buffer->size());
-
-    if (n < (ssize_t)size) {
-        return n < 0 ? (status_t)n : ERROR_MALFORMED;
-    }
-
+    sp<ABuffer> buffer = new ABuffer(16);
+    ssize_t n;
     const uint8_t *data = buffer->data();
+    off64_t current_offset = offset;
 
     while (size > 0) {
+        n = mDataSource->readAt(current_offset, buffer->data(), 16);
+        current_offset += 16;
+
+        if (n < 16) {
+            return ERROR_MALFORMED;
+        }
         uint32_t chunkType = U32_AT(data);
 
         uint8_t hi = chunkType >> 24;
@@ -838,7 +921,6 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
         }
 
         if (track->mKind == Track::OTHER) {
-            data += 16;
             size -= 16;
             continue;
         }
@@ -874,7 +956,6 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
             ++track->mNumSyncSamples;
         }
 
-        data += 16;
         size -= 16;
     }
 
@@ -914,7 +995,7 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
 
             double avgChunkSize = 0;
             size_t j;
-            for (j = 0; j <= numSamplesToAverage; ++j) {
+            for (j = 0; j < numSamplesToAverage; ++j) {
                 off64_t offset;
                 size_t size;
                 bool isKey;
@@ -949,6 +1030,7 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
         ALOGV("track %d duration = %.2f secs", i, durationUs / 1E6);
 
         track->mMeta->setInt64(kKeyDuration, durationUs);
+        track->mMaxSampleSize = (((track->mMaxSampleSize + 15)/16)*16) + 16;
         track->mMeta->setInt32(kKeyMaxInputSize, track->mMaxSampleSize);
 
         const char *tmp;
@@ -972,6 +1054,8 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
                 err = addMPEG4CodecSpecificData(i);
             } else if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_VIDEO_AVC)) {
                 err = addH264CodecSpecificData(i);
+            } else if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_VIDEO_VC1)) {
+                err = addVC1CodecSpecificData(i);
             }
 
             if (err != OK) {
@@ -1038,13 +1122,47 @@ status_t AVIExtractor::addMPEG4CodecSpecificData(size_t trackIndex) {
 
     off64_t offset;
     size_t size;
-    bool isKey;
     int64_t timeUs;
-    status_t err =
-        getSampleInfo(trackIndex, 0, &offset, &size, &isKey, &timeUs);
+    bool isKey = false;
+    bool KeyFound = false;
+    bool NonKeyFound = false;
+    size_t sampleIndex;
+    size_t VOPIndex;
+    size_t NB_SAMPLES_MAX = 100;
+
+    for (sampleIndex = 0; sampleIndex < NB_SAMPLES_MAX; sampleIndex++) {
+        status_t err =
+            getSampleInfo(
+                trackIndex, sampleIndex, &offset, &size, &isKey, &timeUs);
 
-    if (err != OK) {
-        return err;
+        if (err != OK) {
+            return err;
+        }
+        if (size > 0) {
+            if (isKey) {
+                // exit at first key frame
+                KeyFound = true;
+                break;
+            } else {
+                if (!NonKeyFound) {
+                    // save first non-key frame in case no key frame is found
+                    VOPIndex = sampleIndex;
+                    NonKeyFound = true;
+                }
+            }
+        }
+    }
+
+    if (KeyFound) {
+        ALOGV("Extracting specific data from key frame at index=%d size=%d", sampleIndex, size);
+    } else {
+        ALOGW("No key frame found within %d samples, extracting codec-specific data from non-key frame at index = %d, size = %d", NB_SAMPLES_MAX, VOPIndex, size);
+        status_t err =
+            getSampleInfo(
+                trackIndex, VOPIndex, &offset, &size, &isKey, &timeUs);
+        if (err != OK) {
+            return err;
+        }
     }
 
     sp<ABuffer> buffer = new ABuffer(size);
@@ -1138,6 +1256,63 @@ status_t AVIExtractor::addH264CodecSpecificData(size_t trackIndex) {
     return OK;
 }
 
+status_t AVIExtractor::addVC1CodecSpecificData(size_t trackIndex) {
+    Track *track = &mTracks.editItemAt(trackIndex);
+    uint8_t extraData[kSizeOfVC1Info];
+    int32_t width, height;
+
+    CHECK(track->mMeta->findInt32(kKeyWidth, &width));
+    CHECK(track->mMeta->findInt32(kKeyHeight, &height));
+
+    memset(extraData, 0, kSizeOfVC1Info);
+
+    /*************************************************************************************
+      * If the profile is advanced profile (0xC),                                        *
+      *            then the third byte amongst the first 8 bytes is set to 0x1           *
+      *            subsequent STRUCT_C and STRUCT_A information are ignored by decoder   *
+      * Else, for simple (0x0) and main profiles (0x4)                                   *
+      *            populate the STRUCT_C and STRUCT_A information packed as shown below  *
+      *                                                                                  *
+      *  --------------------------------------------------------                        *
+      * |      |      |      |      |      |      |      |      |                        *
+      * |  00  |  00  |  0x  |  00  |  00  |  00  |  00  |  00  |                        *
+      * |      |      |      |      |      |      |      |      |                        *
+      *  --------------------------------------------------------                        *
+      * |      |      |      |      |      |      |      |      |                        *
+      * |  Sc0 |  Sc1 |  Sc2 |  Sc3 |  Sa0 |  Sa1 | Sa2  |  Sa3 |                        *
+      * |      |      |      |      |      |      |      |      |                        *
+      *  -----------------------------------------------                                 *
+      * |      |      |      |      |      |      |      |      |                        *
+      * |  Sa4 |  Sa5 |  Sa6 |  Sa7 |      |      |      |      |                        *
+      * |      |      |      |      |      |      |      |      |                        *
+      *  --------------------------------------------------------                        *
+      ************************************************************************************
+    */
+
+    if (mIsVC1SimpleProfile) {
+        ALOGV("VC1 Simple/Main Profile");
+
+        int32_t extradata_le = U32LE_AT(track->extraData);
+        memcpy(&extraData[8], &extradata_le, 4);
+
+        int32_t height_le = U32LE_AT((uint8_t *)&height);
+        memcpy(&extraData[12], &height_le, 4);
+
+        int32_t width_le = U32LE_AT((uint8_t *)&width);
+        memcpy(&extraData[16], &width_le, 4);
+
+        //storing the extradata in the metadata to enable the accessing of the data globally
+        track->mMeta->setData(kKeyVC1Info, kTypeVC1, extraData, kSizeOfVC1Info);
+    } else if (mIsVC1AdvancedProfile) {
+        ALOGV("VC1 Advanced Profile");
+        track->mMeta->setData(kKeyVC1Info, kTypeVC1, track->apExtraData, track->apExtraDataSize);
+        track->mMaxSampleSize += kSizeOfFrameHeader;
+        free(track->apExtraData);
+    }
+
+    return OK;
+}
+
 status_t AVIExtractor::getSampleInfo(
         size_t trackIndex, size_t sampleIndex,
         off64_t *offset, size_t *size, bool *isKey,
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index af55235..86ebd7f 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -28,8 +28,10 @@ LOCAL_SRC_FILES:=                         \
         AACWriter.cpp                     \
         AMRExtractor.cpp                  \
         AMRWriter.cpp                     \
+        ASFExtractor.cpp                  \
         AudioPlayer.cpp                   \
         AudioSource.cpp                   \
+        AVIExtractor.cpp                  \
         AwesomePlayer.cpp                 \
         CameraSource.cpp                  \
         CameraSourceTimeLapse.cpp         \
@@ -56,10 +58,12 @@ LOCAL_SRC_FILES:=                         \
         MediaSource.cpp                   \
         MetaData.cpp                      \
         NuCachedSource2.cpp               \
+        NuCachedFileSource2.cpp           \
         NuMediaExtractor.cpp              \
         OMXClient.cpp                     \
         OMXCodec.cpp                      \
         OggExtractor.cpp                  \
+        PCMExtractor.cpp                  \
         SampleIterator.cpp                \
         SampleTable.cpp                   \
         SkipCutBuffer.cpp                 \
@@ -88,6 +92,7 @@ LOCAL_C_INCLUDES:= \
         $(TOP)/external/tremolo \
         $(TOP)/external/openssl/include \
 
+
 ifneq ($(TI_CUSTOM_DOMX_PATH),)
 LOCAL_C_INCLUDES += $(TI_CUSTOM_DOMX_PATH)/omx_core/inc
 LOCAL_CPPFLAGS += -DUSE_TI_CUSTOM_DOMX
@@ -147,7 +152,8 @@ LOCAL_SHARED_LIBRARIES := \
         libutils \
         libvorbisidec \
         libz \
-        libpowermanager
+        libpowermanager \
+        libhardware
 
 #QTI FLAC Decoder
 ifeq ($(call is-vendor-board-platform,QCOM),true)
diff --git a/media/libstagefright/AwesomePlayer.cpp b/media/libstagefright/AwesomePlayer.cpp
index 744f4ce..66ac8cd 100644
--- a/media/libstagefright/AwesomePlayer.cpp
+++ b/media/libstagefright/AwesomePlayer.cpp
@@ -30,6 +30,7 @@
 #include "include/DRMExtractor.h"
 #include "include/SoftwareRenderer.h"
 #include "include/NuCachedSource2.h"
+#include "include/NuCachedFileSource2.h"
 #include "include/ThrottledSource.h"
 #include "include/MPEG2TSExtractor.h"
 #include "include/WVMExtractor.h"
@@ -438,7 +439,7 @@ status_t AwesomePlayer::setDataSource(
     }
 #endif
 
-    sp<DataSource> dataSource = new FileSource(fd, offset, length);
+    sp<DataSource> dataSource = new NuCachedFileSource2(new FileSource(fd, offset, length));
 
     status_t err = dataSource->initCheck();
 
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index 4978c08..b7b5b45 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -138,6 +138,10 @@ static int32_t getColorFormat(const char* colorFormat) {
 #endif
     }
 
+    //if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_UYV422I)) {
+    //    return OMX_COLOR_FormatCbYCrY;
+    //}
+
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_RGB565)) {
        return OMX_COLOR_Format16bitRGB565;
     }
@@ -150,6 +154,12 @@ static int32_t getColorFormat(const char* colorFormat) {
         return OMX_COLOR_FormatAndroidOpaque;
     }
 
+#ifdef STE_HARDWARE
+    if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420MB)) {
+       return 0x7FA00000; //OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB
+    }
+#endif
+
     ALOGE("Uknown color format (%s), please add it to "
          "CameraSource::getColorFormat", colorFormat);
 
@@ -596,13 +606,23 @@ status_t CameraSource::initWithCameraAccess(
 
     // XXX: query camera for the stride and slice height
     // when the capability becomes available.
+#ifdef STE_HARDWARE
+    int stride = newCameraParams.getInt(CameraParameters::KEY_RECORD_STRIDE);
+    int sliceHeight = newCameraParams.getInt(CameraParameters::KEY_RECORD_SLICE_HEIGHT);
+#endif
+
     mMeta = new MetaData;
     mMeta->setCString(kKeyMIMEType,  MEDIA_MIMETYPE_VIDEO_RAW);
     mMeta->setInt32(kKeyColorFormat, mColorFormat);
     mMeta->setInt32(kKeyWidth,       mVideoSize.width);
     mMeta->setInt32(kKeyHeight,      mVideoSize.height);
-    mMeta->setInt32(kKeyStride,      mVideoSize.width);
-    mMeta->setInt32(kKeySliceHeight, mVideoSize.height);
+#ifdef STE_HARDWARE
+    mMeta->setInt32(kKeyStride,      stride != -1 ? stride : mVideoSize.width);
+    mMeta->setInt32(kKeySliceHeight, sliceHeight != -1 ? sliceHeight : mVideoSize.height);
+#else
+     mMeta->setInt32(kKeyStride,      mVideoSize.width);
+     mMeta->setInt32(kKeySliceHeight, mVideoSize.height);
+#endif
     mMeta->setInt32(kKeyFrameRate,   mVideoFrameRate);
 
 #ifdef QCOM_HARDWARE
diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index 14b04f9..93bef69 100755
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -29,6 +29,11 @@
 #include "include/MPEG2TSExtractor.h"
 #include "include/MPEG4Extractor.h"
 #include "include/NuCachedSource2.h"
+#ifdef STE_HARDWARE
+#include "include/NuCachedFileSource2.h"
+#include "include/AVIExtractor.h"
+#include "include/ASFExtractor.h"
+#endif
 #include "include/OggExtractor.h"
 #include "include/WAVExtractor.h"
 #include "include/WVMExtractor.h"
@@ -222,6 +227,8 @@ void Sniffer::registerDefaultSniffers() {
     registerSniffer_l(SniffAAC);
     registerSniffer_l(SniffMPEG2PS);
     registerSniffer_l(SniffWVM);
+    registerSniffer_l(SniffAVI);
+    registerSniffer_l(SniffASF);
 #ifdef ENABLE_AV_ENHANCEMENTS
     registerSniffer_l(ExtendedExtractor::Sniff);
 #endif
@@ -261,7 +268,7 @@ sp<DataSource> DataSource::CreateFromURI(
 
     sp<DataSource> source;
     if (!strncasecmp("file://", uri, 7)) {
-        source = new FileSource(uri + 7);
+        source = new NuCachedFileSource2(new FileSource(uri + 7));
     } else if (!strncasecmp("http://", uri, 7)
             || !strncasecmp("https://", uri, 8)
             || isWidevine) {
@@ -303,13 +310,16 @@ sp<DataSource> DataSource::CreateFromURI(
 #endif
     } else {
         // Assume it's a filename.
-        source = new FileSource(uri);
+        source = new NuCachedFileSource2(new FileSource(uri));
     }
 
     if (source == NULL || source->initCheck() != OK) {
         return NULL;
     }
 
+    // Save uri
+    source->setCharUri(uri);
+
     return source;
 }
 
@@ -317,4 +327,12 @@ String8 DataSource::getMIMEType() const {
     return String8("application/octet-stream");
 }
 
+void DataSource::setCharUri(const char* uri) {
+    mUri = String8(uri);
+}
+
+const char* DataSource::getCharUri() {
+    return mUri.string();
+}
+
 }  // namespace android
diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index d1b4381..098c0f0 100644
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -1524,15 +1524,25 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
 
         case FOURCC('c', 't', 't', 's'):
         {
+            uint32_t consumed_offset;
             status_t err =
                 mLastTrack->sampleTable->setCompositionTimeToSampleParams(
-                        data_offset, chunk_data_size);
+                        data_offset, chunk_data_size, &consumed_offset);
 
             if (err != OK) {
                 return err;
             }
 
-            *offset += chunk_size;
+            off64_t chunk_end = *offset + chunk_size;
+            *offset = data_offset + consumed_offset;
+
+            if (*offset < chunk_end) {
+                // Parse 'free' or 'skip' box
+                status_t err = parseChunk(offset, depth + 1);
+                if (err != OK) {
+                    return err;
+                }
+            }
             break;
         }
 
@@ -1884,6 +1894,12 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             return UNKNOWN_ERROR; // stop parsing after sidx
         }
 
+        case FOURCC('f', 'r', 'e', 'e'):
+        case FOURCC('s', 'k', 'i', 'p'):
+        {
+            *offset += chunk_size;
+            break;
+        }
         default:
         {
             *offset += chunk_size;
@@ -2330,7 +2346,8 @@ status_t MPEG4Extractor::verifyTrack(Track *track) {
             return ERROR_MALFORMED;
         }
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_MPEG4)
-            || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)) {
+            || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)
+            || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC_ELD)) {
         if (!track->meta->findData(kKeyESDS, &type, &data, &size)
                 || type != kTypeESDS) {
             return ERROR_MALFORMED;
@@ -2375,6 +2392,17 @@ status_t MPEG4Extractor::updateAudioTrackInfoFromESDS_MPEG4Audio(
          return OK;
     }
 #else
+#ifdef STE_HARDWARE
+    if (objectTypeIndication  == 0x6b || objectTypeIndication == 0x69) {
+         // The media subtype is MP3 audio
+         // Our software MP3 audio decoder may not be able to handle
+
+        // packetized MP3 audio;
+        ALOGE("MP3 track in MP4/3GPP file is not supported, "
+            "continuing playback");
+        return OK;
+     }
+#else
     if (objectTypeIndication  == 0x6b) {
         // The media subtype is MP3 audio
         // Our software MP3 audio decoder may not be able to handle
@@ -2383,6 +2411,7 @@ status_t MPEG4Extractor::updateAudioTrackInfoFromESDS_MPEG4Audio(
         return ERROR_UNSUPPORTED;
     }
 #endif
+#endif
 
     const uint8_t *csd;
     size_t csd_size;
@@ -2418,6 +2447,7 @@ status_t MPEG4Extractor::updateAudioTrackInfoFromESDS_MPEG4Audio(
 
     if (objectType == 31) {  // AAC-ELD => additional 6 bits
         objectType = 32 + br.getBits(6);
+        mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AAC_ELD);
     }
 
 #ifdef QCOM_DIRECTTRACK
@@ -3881,7 +3911,7 @@ static bool BetterSniffMPEG4(
             case FOURCC('m', 'o', 'o', 'v'):
             {
                 moovAtomEndOffset = offset + chunkSize;
-
+                foundGoodFileType = true;
                 done = true;
                 break;
             }
diff --git a/media/libstagefright/MPEG4Writer.cpp b/media/libstagefright/MPEG4Writer.cpp
index 1546a7e..c826cf1 100644
--- a/media/libstagefright/MPEG4Writer.cpp
+++ b/media/libstagefright/MPEG4Writer.cpp
@@ -2481,6 +2481,7 @@ status_t MPEG4Writer::Track::threadEntry() {
 
         // use File write in seperate thread for video only recording
         if (!hasMultipleTracks && mIsAudio) {
+#ifndef STE_HARDWARE
 #if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP3)
             off64_t offset = mOwner->addSample_l(copy);
 #else
@@ -2496,6 +2497,10 @@ status_t MPEG4Writer::Track::threadEntry() {
             }
             copy->release();
             copy = NULL;
+#else
+            mChunkSamples.push_back(copy);
+            bufferChunk(timestampUs);
+#endif
             continue;
         }
 
diff --git a/media/libstagefright/MediaDefs.cpp b/media/libstagefright/MediaDefs.cpp
index 6a69740..bd2401f 100644
--- a/media/libstagefright/MediaDefs.cpp
+++ b/media/libstagefright/MediaDefs.cpp
@@ -25,6 +25,9 @@ const char *MEDIA_MIMETYPE_VIDEO_VP9 = "video/x-vnd.on2.vp9";
 const char *MEDIA_MIMETYPE_VIDEO_AVC = "video/avc";
 const char *MEDIA_MIMETYPE_VIDEO_MPEG4 = "video/mp4v-es";
 const char *MEDIA_MIMETYPE_VIDEO_H263 = "video/3gpp";
+#ifdef STE_HARDWARE
+const char *MEDIA_MIMETYPE_VIDEO_H263_SW = "video/3gpp-sw";
+#endif
 const char *MEDIA_MIMETYPE_VIDEO_MPEG2 = "video/mpeg2";
 const char *MEDIA_MIMETYPE_VIDEO_RAW = "video/raw";
 
@@ -34,6 +37,7 @@ const char *MEDIA_MIMETYPE_AUDIO_MPEG = "audio/mpeg";
 const char *MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_I = "audio/mpeg-L1";
 const char *MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II = "audio/mpeg-L2";
 const char *MEDIA_MIMETYPE_AUDIO_AAC = "audio/mp4a-latm";
+const char *MEDIA_MIMETYPE_AUDIO_AAC_ELD = "audio/mp4a-eld";
 const char *MEDIA_MIMETYPE_AUDIO_QCELP = "audio/qcelp";
 const char *MEDIA_MIMETYPE_AUDIO_VORBIS = "audio/vorbis";
 const char *MEDIA_MIMETYPE_AUDIO_G711_ALAW = "audio/g711-alaw";
@@ -64,7 +68,9 @@ const char *MEDIA_MIMETYPE_VIDEO_DIVX4 = "video/divx4";
 const char *MEDIA_MIMETYPE_VIDEO_FLV1 = "video/x-flv";
 const char *MEDIA_MIMETYPE_VIDEO_MJPEG = "video/x-jpeg";
 const char *MEDIA_MIMETYPE_VIDEO_RV = "video/vnd.rn-realvideo";
+#ifdef STE_HARDWARE
 const char *MEDIA_MIMETYPE_VIDEO_VC1 = "video/vc1";
+#endif
 const char *MEDIA_MIMETYPE_VIDEO_WMV = "video/x-ms-wmv";
 const char *MEDIA_MIMETYPE_VIDEO_HEVC = "video/hevc";
 const char *MEDIA_MIMETYPE_VIDEO_FFMPEG = "video/ffmpeg";
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
index c90937e..21b8f71 100755
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -19,16 +19,19 @@
 #include <utils/Log.h>
 
 #include "include/AMRExtractor.h"
+#include "include/AVIExtractor.h"
 #include "include/MP3Extractor.h"
 #include "include/MPEG4Extractor.h"
 #include "include/WAVExtractor.h"
 #include "include/OggExtractor.h"
+#include "include/PCMExtractor.h"
 #include "include/MPEG2PSExtractor.h"
 #include "include/MPEG2TSExtractor.h"
 #include "include/DRMExtractor.h"
 #include "include/WVMExtractor.h"
 #include "include/FLACExtractor.h"
 #include "include/AACExtractor.h"
+#include "include/ASFExtractor.h"
 
 #include "matroska/MatroskaExtractor.h"
 
@@ -126,6 +129,8 @@ retry:
         ret = new MatroskaExtractor(source);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2TS)) {
         ret = new MPEG2TSExtractor(source);
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_AVI)) {
+        ret = new AVIExtractor(source);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WVM)) {
         // Return now.  WVExtractor should not have the DrmFlag set in the block below.
         return new WVMExtractor(source);
@@ -135,6 +140,12 @@ retry:
         ret = new MPEG2PSExtractor(source);
     } else if (sPlugin.create) {
         ret = sPlugin.create(source, mime, meta);
+#ifdef STE_HARDWARE
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) {
+        ret = new PCMExtractor(source);
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_ASF)) {
+        ret = new ASFExtractor(source);
+#endif
     }
 
     if (ret != NULL) {
diff --git a/media/libstagefright/NuCachedFileSource2.cpp b/media/libstagefright/NuCachedFileSource2.cpp
new file mode 100644
index 0000000..5a6f086
--- /dev/null
+++ b/media/libstagefright/NuCachedFileSource2.cpp
@@ -0,0 +1,735 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "NuCachedFileSource2"
+#include <utils/Log.h>
+
+#include "include/NuCachedFileSource2.h"
+#include "include/HTTPBase.h"
+
+#include <cutils/properties.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/MediaErrors.h>
+
+namespace android {
+
+struct PageFileCache {
+    PageFileCache(size_t pageSize);
+    ~PageFileCache();
+
+    struct Page {
+        void *mData;
+        size_t mSize;
+    };
+
+    Page *acquirePage();
+    void releasePage(Page *page);
+
+    void appendPage(Page *page);
+    size_t releaseFromStart(size_t maxBytes);
+
+    size_t totalSize() const {
+        return mTotalSize;
+    }
+
+    void copy(size_t from, void *data, size_t size);
+
+private:
+    size_t mPageSize;
+    size_t mTotalSize;
+
+    List<Page *> mActivePages;
+    List<Page *> mFreePages;
+
+    void freePages(List<Page *> *list);
+
+    DISALLOW_EVIL_CONSTRUCTORS(PageFileCache);
+};
+
+PageFileCache::PageFileCache(size_t pageSize)
+    : mPageSize(pageSize),
+      mTotalSize(0) {
+}
+
+PageFileCache::~PageFileCache() {
+    freePages(&mActivePages);
+    freePages(&mFreePages);
+}
+
+void PageFileCache::freePages(List<Page *> *list) {
+    List<Page *>::iterator it = list->begin();
+    while (it != list->end()) {
+        Page *page = *it;
+
+        free(page->mData);
+        delete page;
+        page = NULL;
+
+        ++it;
+    }
+}
+
+PageFileCache::Page *PageFileCache::acquirePage() {
+    if (!mFreePages.empty()) {
+        List<Page *>::iterator it = mFreePages.begin();
+        Page *page = *it;
+        mFreePages.erase(it);
+
+        return page;
+    }
+
+    Page *page = new Page;
+    page->mData = malloc(mPageSize);
+    page->mSize = 0;
+
+    return page;
+}
+
+void PageFileCache::releasePage(Page *page) {
+    page->mSize = 0;
+    mFreePages.push_back(page);
+}
+
+void PageFileCache::appendPage(Page *page) {
+    mTotalSize += page->mSize;
+    mActivePages.push_back(page);
+}
+
+size_t PageFileCache::releaseFromStart(size_t maxBytes) {
+    size_t bytesReleased = 0;
+
+    while (maxBytes > 0 && !mActivePages.empty()) {
+        List<Page *>::iterator it = mActivePages.begin();
+
+        Page *page = *it;
+
+        if (maxBytes < page->mSize) {
+            break;
+        }
+
+        mActivePages.erase(it);
+
+        maxBytes -= page->mSize;
+        bytesReleased += page->mSize;
+
+        releasePage(page);
+    }
+
+    mTotalSize -= bytesReleased;
+    return bytesReleased;
+}
+
+void PageFileCache::copy(size_t from, void *data, size_t size) {
+    ALOGV("copy from %d size %d", from, size);
+
+    if (size == 0) {
+        return;
+    }
+
+    CHECK_LE(from + size, mTotalSize);
+
+    size_t offset = 0;
+    List<Page *>::iterator it = mActivePages.begin();
+    while (from >= offset + (*it)->mSize) {
+        offset += (*it)->mSize;
+        ++it;
+    }
+
+    size_t delta = from - offset;
+    size_t avail = (*it)->mSize - delta;
+
+    if (avail >= size) {
+        memcpy(data, (const uint8_t *)(*it)->mData + delta, size);
+        return;
+    }
+
+    memcpy(data, (const uint8_t *)(*it)->mData + delta, avail);
+    ++it;
+    data = (uint8_t *)data + avail;
+    size -= avail;
+
+    while (size > 0) {
+        size_t copy = (*it)->mSize;
+        if (copy > size) {
+            copy = size;
+        }
+        memcpy(data, (*it)->mData, copy);
+        data = (uint8_t *)data + copy;
+        size -= copy;
+        ++it;
+    }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+NuCachedFileSource2::NuCachedFileSource2(
+        const sp<DataSource> &source,
+        const char *cacheConfig,
+        bool disconnectAtHighwatermark)
+    : mSource(source),
+      mReflector(new AHandlerReflector<NuCachedFileSource2>(this)),
+      mLooper(new ALooper),
+      mCache(new PageFileCache(kPageSize)),
+      mCacheOffset(0),
+      mFinalStatus(OK),
+      mLastAccessPos(0),
+      mFetching(true),
+      mLastFetchTimeUs(-1),
+      mLastFetchEventTimeUs(0),
+      mNumRetriesLeft(kMaxNumRetries),
+      mHighwaterThresholdBytes(kDefaultHighWaterThreshold),
+      mLowwaterThresholdBytes(kDefaultLowWaterThreshold),
+      mKeepAliveIntervalUs(kDefaultKeepAliveIntervalUs),
+      mDisconnectAtHighwatermark(disconnectAtHighwatermark),
+      mNbrSeeks(0),
+      mNbrReads(0),
+      mBypassCache(false) {
+    // We are NOT going to support disconnect-at-highwatermark indefinitely
+    // and we are not guaranteeing support for client-specified cache
+    // parameters. Both of these are temporary measures to solve a specific
+    // problem that will be solved in a better way going forward.
+
+    updateCacheParamsFromSystemProperty();
+
+    if (cacheConfig != NULL) {
+        updateCacheParamsFromString(cacheConfig);
+    }
+
+    if (mDisconnectAtHighwatermark) {
+        // Makes no sense to disconnect and do keep-alives...
+        mKeepAliveIntervalUs = 0;
+    }
+
+    mLooper->setName("NuCachedFileSource2");
+    mLooper->registerHandler(mReflector);
+    mLooper->start();
+
+    Mutex::Autolock autoLock(mLock);
+    (new AMessage(kWhatFetchMore, mReflector->id()))->post();
+}
+
+NuCachedFileSource2::~NuCachedFileSource2() {
+    mLooper->stop();
+    mLooper->unregisterHandler(mReflector->id());
+
+    delete mCache;
+    mCache = NULL;
+}
+
+status_t NuCachedFileSource2::getEstimatedBandwidthKbps(int32_t *kbps) {
+    if (mSource->flags() & kIsHTTPBasedSource) {
+        HTTPBase* source = static_cast<HTTPBase *>(mSource.get());
+        return source->getEstimatedBandwidthKbps(kbps);
+    }
+    return ERROR_UNSUPPORTED;
+}
+
+status_t NuCachedFileSource2::setCacheStatCollectFreq(int32_t freqMs) {
+    if (mSource->flags() & kIsHTTPBasedSource) {
+        HTTPBase *source = static_cast<HTTPBase *>(mSource.get());
+        return source->setBandwidthStatCollectFreq(freqMs);
+    }
+    return ERROR_UNSUPPORTED;
+}
+
+status_t NuCachedFileSource2::initCheck() const {
+    return mSource->initCheck();
+}
+
+status_t NuCachedFileSource2::getSize(off64_t *size) {
+    return mSource->getSize(size);
+}
+
+uint32_t NuCachedFileSource2::flags() {
+    // Remove HTTP related flags since NuCachedFileSource2 is not HTTP-based.
+    uint32_t flags = mSource->flags() & ~(kWantsPrefetching | kIsHTTPBasedSource);
+    return (flags | kIsCachingDataSource);
+}
+
+void NuCachedFileSource2::onMessageReceived(const sp<AMessage> &msg) {
+    switch (msg->what()) {
+        case kWhatFetchMore:
+        {
+            onFetch();
+            break;
+        }
+
+        case kWhatRead:
+        {
+            onRead(msg);
+            break;
+        }
+
+        default:
+            TRESPASS();
+    }
+}
+
+void NuCachedFileSource2::fetchInternal() {
+    ALOGV("fetchInternal");
+
+    bool reconnect = false;
+
+    {
+        Mutex::Autolock autoLock(mLock);
+        CHECK(mFinalStatus == OK || mNumRetriesLeft > 0);
+
+        if (mFinalStatus != OK) {
+            --mNumRetriesLeft;
+
+            reconnect = true;
+        }
+    }
+
+    if (reconnect) {
+        status_t err =
+            mSource->reconnectAtOffset(mCacheOffset + mCache->totalSize());
+
+        Mutex::Autolock autoLock(mLock);
+
+        if (err == ERROR_UNSUPPORTED) {
+            mNumRetriesLeft = 0;
+            return;
+        } else if (err != OK) {
+            ALOGI("The attempt to reconnect failed, %d retries remaining",
+                 mNumRetriesLeft);
+
+            return;
+        }
+    }
+
+    PageFileCache::Page *page = mCache->acquirePage();
+
+    ssize_t n = mSource->readAt(
+            mCacheOffset + mCache->totalSize(), page->mData, kPageSize);
+
+    Mutex::Autolock autoLock(mLock);
+
+    if (n < 0) {
+        ALOGE("source returned error %ld, %d retries left", n, mNumRetriesLeft);
+        mFinalStatus = n;
+        mCache->releasePage(page);
+    } else if (n == 0) {
+        ALOGI("ERROR_END_OF_STREAM");
+
+        mNumRetriesLeft = 0;
+        mFinalStatus = ERROR_END_OF_STREAM;
+
+        mCache->releasePage(page);
+    } else {
+        if (mFinalStatus != OK) {
+            ALOGI("retrying a previously failed read succeeded.");
+        }
+        mNumRetriesLeft = kMaxNumRetries;
+        mFinalStatus = OK;
+
+        page->mSize = n;
+        mCache->appendPage(page);
+    }
+}
+
+void NuCachedFileSource2::onFetch() {
+    ALOGV("onFetch");
+
+    int64_t now = ALooper::GetNowUs();
+    if (mFinalStatus != OK && mNumRetriesLeft == 0) {
+        ALOGV("EOS reached, done prefetching for now");
+        mFetching = false;
+    }
+
+    if (mFetching) {
+        fetchInternal();
+
+        mLastFetchTimeUs = now;
+
+        if (mFetching && mCache->totalSize() >= mHighwaterThresholdBytes) {
+            ALOGI("Cache full, done prefetching for now");
+            mFetching = false;
+
+            if (mDisconnectAtHighwatermark
+                    && (mSource->flags() & DataSource::kIsHTTPBasedSource)) {
+                ALOGV("Disconnecting at high watermark");
+                static_cast<HTTPBase *>(mSource.get())->disconnect();
+                mFinalStatus = -EAGAIN;
+            }
+        }
+    } else {
+        Mutex::Autolock autoLock(mLock);
+        restartPrefetcherIfNecessary_l();
+    }
+
+    if (mFetching) {
+        mLastFetchEventTimeUs = now;
+        (new AMessage(kWhatFetchMore, mReflector->id()))->post();
+    }
+
+}
+
+void NuCachedFileSource2::onRead(const sp<AMessage> &msg) {
+    ALOGV("onRead");
+
+    int64_t offset;
+    CHECK(msg->findInt64("offset", &offset));
+
+    void *data;
+    CHECK(msg->findPointer("data", &data));
+
+    size_t size;
+    CHECK(msg->findSize("size", &size));
+
+    ssize_t result = readInternal(offset, data, size);
+
+    if (result == -EAGAIN) {
+        msg->post(10000);
+        int64_t now = ALooper::GetNowUs();
+        if (now - mLastFetchEventTimeUs > kFetchDeferredIntervalUs) {
+            mLastFetchEventTimeUs = now;
+            (new AMessage(kWhatFetchMore, mReflector->id()))->post();
+        }
+        return;
+    }
+
+    Mutex::Autolock autoLock(mLock);
+
+    CHECK(mAsyncResult == NULL);
+
+    mAsyncResult = new AMessage;
+    mAsyncResult->setInt32("result", result);
+
+    mCondition.signal();
+}
+
+void NuCachedFileSource2::restartPrefetcherIfNecessary_l(
+        bool ignoreLowWaterThreshold, bool force) {
+    static const size_t kGrayArea = 3 * 1024 * 1024;
+
+    if (mFetching || (mFinalStatus != OK && mNumRetriesLeft == 0)) {
+        return;
+    }
+
+    if (!ignoreLowWaterThreshold && !force
+            && mCacheOffset + mCache->totalSize() - mLastAccessPos
+                >= mLowwaterThresholdBytes) {
+        return;
+    }
+
+    size_t maxBytes = mLastAccessPos - mCacheOffset;
+
+    if (!force) {
+        if (maxBytes < kGrayArea) {
+            return;
+        }
+
+        maxBytes -= kGrayArea;
+    }
+
+    size_t actualBytes = mCache->releaseFromStart(maxBytes);
+    mCacheOffset += actualBytes;
+
+    ALOGI("restarting prefetcher, totalSize = %d", mCache->totalSize());
+    mFetching = true;
+}
+
+ssize_t NuCachedFileSource2::readAt(off64_t offset, void *data, size_t size) {
+    Mutex::Autolock autoSerializer(mSerializer);
+
+    ALOGV("readAt offset %lld, size %d", offset, size);
+
+    Mutex::Autolock autoLock(mLock);
+
+    int64_t now = ALooper::GetNowUs();
+
+    ++mNbrReads;
+
+    // If the request can be completely satisfied from the cache, do so.
+
+    if (offset >= mCacheOffset
+            && offset + size <= mCacheOffset + mCache->totalSize()) {
+        size_t delta = offset - mCacheOffset;
+        mCache->copy(delta, data, size);
+
+        mLastAccessPos = offset + size;
+
+        if (now - mLastFetchEventTimeUs > kFetchIntervalUs) {
+            mLastFetchEventTimeUs = now;
+            (new AMessage(kWhatFetchMore, mReflector->id()))->post();
+        }
+        return size;
+    }
+
+    sp<AMessage> msg = new AMessage(kWhatRead, mReflector->id());
+    msg->setInt64("offset", offset);
+    msg->setPointer("data", data);
+    msg->setSize("size", size);
+
+    CHECK(mAsyncResult == NULL);
+    msg->post();
+
+    while (mAsyncResult == NULL) {
+        mCondition.wait(mLock);
+    }
+
+    int32_t result;
+    CHECK(mAsyncResult->findInt32("result", &result));
+
+    mAsyncResult.clear();
+
+    if (result > 0) {
+        mLastAccessPos = offset + result;
+    }
+
+    if (now - mLastFetchEventTimeUs > kFetchIntervalUs) {
+        mLastFetchEventTimeUs = now;
+        (new AMessage(kWhatFetchMore, mReflector->id()))->post();
+    }
+    return (ssize_t)result;
+}
+
+size_t NuCachedFileSource2::cachedSize() {
+    Mutex::Autolock autoLock(mLock);
+    return mCacheOffset + mCache->totalSize();
+}
+
+size_t NuCachedFileSource2::approxDataRemaining(status_t *finalStatus) const {
+    Mutex::Autolock autoLock(mLock);
+    return approxDataRemaining_l(finalStatus);
+}
+
+size_t NuCachedFileSource2::approxDataRemaining_l(status_t *finalStatus) const {
+    *finalStatus = mFinalStatus;
+
+    if (mFinalStatus != OK && mNumRetriesLeft > 0) {
+        // Pretend that everything is fine until we're out of retries.
+        *finalStatus = OK;
+    }
+
+    off64_t lastBytePosCached = mCacheOffset + mCache->totalSize();
+    if (mLastAccessPos < lastBytePosCached) {
+        return lastBytePosCached - mLastAccessPos;
+    }
+    return 0;
+}
+
+ssize_t NuCachedFileSource2::readInternal(off64_t offset, void *data, size_t size) {
+    if (size > (size_t)mHighwaterThresholdBytes) {
+        return -EINVAL;
+    }
+    ALOGV("readInternal offset %lld size %d", offset, size);
+
+    if (mBypassCache) {
+        if  (mNbrReads > kBypassCacheDuration) {
+            ALOGI("try to enable cache again");
+            mBypassCache = false;
+            mNbrReads = 0;
+            mNbrSeeks = 0;
+        }
+        return mSource->readAt(offset, data, size);
+    }
+
+    Mutex::Autolock autoLock(mLock);
+
+    if (!mFetching) {
+        mLastAccessPos = offset;
+        restartPrefetcherIfNecessary_l(
+                false, // ignoreLowWaterThreshold
+                true); // force
+    }
+
+    if (offset < mCacheOffset
+            || offset >= (off64_t)(mCacheOffset + mCache->totalSize())
+            || (!mFetching
+                && offset <= (off_t)(mCacheOffset + mCache->totalSize())
+                && offset + size > mCacheOffset + mCache->totalSize())) {
+        static const off64_t kPadding = 256 * 1024;
+
+        // In the presence of multiple decoded streams, once of them will
+        // trigger this seek request, the other one will request data "nearby"
+        // soon, adjust the seek position so that that subsequent request
+        // does not trigger another seek.
+        off64_t seekOffset = (offset > kPadding) ? offset - kPadding : 0;
+
+        seekInternal_l(seekOffset);
+    }
+
+    size_t delta = offset - mCacheOffset;
+
+    if (mFinalStatus != OK && mNumRetriesLeft == 0) {
+        if (delta >= mCache->totalSize()) {
+            return mFinalStatus;
+        }
+
+        size_t avail = mCache->totalSize() - delta;
+
+        if (avail > size) {
+            avail = size;
+        }
+
+        mCache->copy(delta, data, avail);
+
+        return avail;
+    }
+
+    if (offset + size <= mCacheOffset + mCache->totalSize()) {
+        mCache->copy(delta, data, size);
+
+        return size;
+    }
+
+    ALOGV("deferring read");
+
+    return -EAGAIN;
+}
+
+status_t NuCachedFileSource2::seekInternal_l(off64_t offset) {
+    mLastAccessPos = offset;
+
+    if (offset >= mCacheOffset
+            && offset <= (off64_t)(mCacheOffset + mCache->totalSize())) {
+        return OK;
+    }
+
+    ++mNbrSeeks;
+    if (mNbrReads >= kBypassCacheCheckTrigger) {
+        if (mNbrSeeks * 100 / mNbrReads >= kBypassCacheThreshold) {
+            ALOGI("too many cache misses, bypassing cache");
+            mBypassCache = true;
+        }
+        mNbrReads = 0;
+        mNbrSeeks = 0;
+    }
+
+    ALOGI("new range: offset= %lld", offset);
+
+    mCacheOffset = offset;
+
+    size_t totalSize = mCache->totalSize();
+    CHECK_EQ(mCache->releaseFromStart(totalSize), totalSize);
+
+    mNumRetriesLeft = kMaxNumRetries;
+    mFinalStatus = OK;
+    mFetching = true;
+
+    mLastFetchEventTimeUs = ALooper::GetNowUs();
+    (new AMessage(kWhatFetchMore, mReflector->id()))->post();
+
+    return OK;
+}
+
+void NuCachedFileSource2::resumeFetchingIfNecessary() {
+    Mutex::Autolock autoLock(mLock);
+
+    restartPrefetcherIfNecessary_l(true /* ignore low water threshold */);
+}
+
+sp<DecryptHandle> NuCachedFileSource2::DrmInitialization(const char* mime) {
+    return mSource->DrmInitialization(mime);
+}
+
+void NuCachedFileSource2::getDrmInfo(sp<DecryptHandle> &handle, DrmManagerClient **client) {
+    mSource->getDrmInfo(handle, client);
+}
+
+String8 NuCachedFileSource2::getUri() {
+    return mSource->getUri();
+}
+
+String8 NuCachedFileSource2::getMIMEType() const {
+    return mSource->getMIMEType();
+}
+
+void NuCachedFileSource2::updateCacheParamsFromSystemProperty() {
+    char value[PROPERTY_VALUE_MAX];
+    if (!property_get("media.stagefright.cache-params", value, NULL)) {
+        return;
+    }
+
+    updateCacheParamsFromString(value);
+}
+
+void NuCachedFileSource2::updateCacheParamsFromString(const char *s) {
+    ssize_t lowwaterMarkKb, highwaterMarkKb;
+    int keepAliveSecs;
+
+    if (sscanf(s, "%ld/%ld/%d",
+               &lowwaterMarkKb, &highwaterMarkKb, &keepAliveSecs) != 3) {
+        ALOGE("Failed to parse cache parameters from '%s'.", s);
+        return;
+    }
+
+    if (lowwaterMarkKb >= 0) {
+        mLowwaterThresholdBytes = lowwaterMarkKb * 1024;
+    } else {
+        mLowwaterThresholdBytes = kDefaultLowWaterThreshold;
+    }
+
+    if (highwaterMarkKb >= 0) {
+        mHighwaterThresholdBytes = highwaterMarkKb * 1024;
+    } else {
+        mHighwaterThresholdBytes = kDefaultHighWaterThreshold;
+    }
+
+    if (mLowwaterThresholdBytes >= mHighwaterThresholdBytes) {
+        ALOGE("Illegal low/highwater marks specified, reverting to defaults.");
+
+        mLowwaterThresholdBytes = kDefaultLowWaterThreshold;
+        mHighwaterThresholdBytes = kDefaultHighWaterThreshold;
+    }
+
+    if (keepAliveSecs >= 0) {
+        mKeepAliveIntervalUs = keepAliveSecs * 1000000ll;
+    } else {
+        mKeepAliveIntervalUs = kDefaultKeepAliveIntervalUs;
+    }
+
+    ALOGV("lowwater = %d bytes, highwater = %d bytes, keepalive = %lld us",
+         mLowwaterThresholdBytes,
+         mHighwaterThresholdBytes,
+         mKeepAliveIntervalUs);
+}
+
+// static
+void NuCachedFileSource2::RemoveCacheSpecificHeaders(
+        KeyedVector<String8, String8> *headers,
+        String8 *cacheConfig,
+        bool *disconnectAtHighwatermark) {
+    *cacheConfig = String8();
+    *disconnectAtHighwatermark = false;
+
+    if (headers == NULL) {
+        return;
+    }
+
+    ssize_t index;
+    if ((index = headers->indexOfKey(String8("x-cache-config"))) >= 0) {
+        *cacheConfig = headers->valueAt(index);
+
+        headers->removeItemsAt(index);
+
+        ALOGV("Using special cache config '%s'", cacheConfig->string());
+    }
+
+    if ((index = headers->indexOfKey(
+                    String8("x-disconnect-at-highwatermark"))) >= 0) {
+        *disconnectAtHighwatermark = true;
+        headers->removeItemsAt(index);
+
+        ALOGV("Client requested disconnection at highwater mark");
+    }
+}
+
+}  // namespace android
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index fc58bfd..d92dcc2 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -361,6 +361,24 @@ void OMXCodec::findMatchingCodecs(
     }
 }
 
+#ifdef STE_HARDWARE
+//static
+uint32_t OMXCodec::OmxToHALFormat(OMX_COLOR_FORMATTYPE omxValue) {
+    switch (omxValue) {
+        case 0x7FA00000: //OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB
+            return HAL_PIXEL_FORMAT_YCBCR42XMBN;
+        case OMX_COLOR_FormatYUV420Planar:
+            return HAL_PIXEL_FORMAT_YCbCr_420_P;
+        case OMX_COLOR_FormatYUV420SemiPlanar:
+            return HAL_PIXEL_FORMAT_YCbCr_420_SP;
+        default:
+            ALOGI("Unknown OMX pixel format (0x%X), passing it on unchanged", omxValue);
+            return omxValue;
+    }
+}
+#endif
+
+
 // static
 uint32_t OMXCodec::getComponentQuirks(
         const MediaCodecList *list, size_t index) {
@@ -451,6 +469,18 @@ uint32_t OMXCodec::getComponentQuirks(
     quirks |= ExtendedCodec::getComponentQuirks(list,index);
 #endif
 
+#ifdef STE_HARDWARE
+    if (list->codecHasQuirk(
+                index, "requires-store-metadata-before-idle")) {
+        quirks |= kRequiresStoreMetaDataBeforeIdle;
+        quirks |= kStoreMetaDataInVideoBuffers;
+    }
+    if (list->codecHasQuirk(
+                index, "override-default-avc-profile")) {
+        quirks |= kOverrideDefaultAVCProfile;
+    }
+#endif
+
     return quirks;
 }
 
@@ -690,6 +720,56 @@ status_t OMXCodec::parseAVCCodecSpecificData(
     return OK;
 }
 
+status_t OMXCodec::parseVC1CodecSpecificData(
+        const void *data, size_t size) {
+    static const uint32_t kVC1StartCode = 0x000001;
+    const uint8_t *ptr = (const uint8_t *)data;
+    uint32_t startCode = 0;
+
+    //************************************************************************************
+    // strf chunk of AVI stream has Sequence Header and Entry point Header which are     *
+    // specific to VC1-advanced profile stream                                           *
+    // --------------------------------------------------------------------------------- *
+    //                           'strf' Chunk                                            *
+    //         Sequence Header Start Code(SH)     --> 0x00 00 01 0f                      *
+    //         Entry Point Header Start Code(EPH) --> 0x00 00 01 0e                      *
+    // strf Chunk starts with 4 bytes of ChunkSize, 4 bytes of Width & 4 bytes of Height *
+    // followed by SH and EPH as shown below. Size of SH & EPH would not be part of      *
+    // stream data, needs to identify the same based on strf Chunk size                  *
+    // -----------------------------------------------------------------------           *
+    // |      |      |      |      |      |      |      |      |      |      |           *
+    // |  00  |  00  |  01  |  0f  |  xx  |  xx  |  xx  |  xx  |  xx  |  xx  |           *
+    // |      |      |      |      |      |      |      |      |      |      |           *
+    // -----------------------------------------------------------------------           *
+    // |      |      |      |      |      |      |      |      |      |      |           *
+    // |  00  |  00  |  01  |  0e  |  xx  |  xx  |  xx  |  xx  |  xx  |  xx  |           *
+    // |      |      |      |      |      |      |      |      |      |      |           *
+    // -----------------------------------------------------------------------           *
+    // minimum size should be less than 6 bytes as header is of 4 bytes                  *
+    // and atleast 1 byte of data. Checking for VC1 Start Code                           *
+    //***********************************************************************************/
+
+    startCode = (ptr[0] << 16) | (ptr[1] << 8) | ptr[2];
+    if (size < 6 || startCode != kVC1StartCode) {
+        return ERROR_MALFORMED;
+    }
+
+    // ReSync to the next start code to separate Sequence Header and Entry Point Header
+    uint32_t dataindex = 2;
+    uint32_t sizeOfSequenceHeader, sizeOfEntryPointHeader;
+    startCode = 0;
+    while (startCode != kVC1StartCode && dataindex < size) {
+        dataindex++;
+        startCode = (ptr[dataindex] << 16) | (ptr[dataindex + 1] << 8) |
+                ptr[dataindex + 2];
+    }
+    sizeOfSequenceHeader = dataindex;
+    addCodecSpecificData(ptr, sizeOfSequenceHeader);
+    sizeOfEntryPointHeader = size - dataindex;
+    addCodecSpecificData(ptr + dataindex, sizeOfEntryPointHeader);
+    return OK;
+}
+
 status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
     ALOGV("configureCodec protected=%d",
          (mFlags & kEnableGrallocUsageProtected) ? 1 : 0);
@@ -856,6 +936,22 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
         if (meta->findData(kKeyAacCodecSpecificData, &type, &data, &size)) {
             ALOGV("OMXCodec:: configureCodec found kKeyAacCodecSpecificData of size %d\n", size);
             addCodecSpecificData(data, size);
+        } else if (meta->findData(kKeyWMAInfo, &type, &data, &size)) {
+            addCodecSpecificData(data, size);
+        } else if (meta->findData(kKeyVC1Info, &type, &data, &size)) {
+            status_t err;
+            // *************************************************************** *
+            // In case of VC-1 Advanced Profile, the following function shall  *
+            // parse the metadata, generate the codecSpecificData and push the *
+            // same into codecSpecificData List and return a OK                *
+            // In case of VC-1 Simple or Main Profile streams, the function    *
+            // returns an error code based on which the codecSpecificData      *
+            // generated by the extractor is directly pushed into the list.    *
+            // *************************************************************** *
+            err = parseVC1CodecSpecificData(data, size);
+            if (err != OK) {
+                addCodecSpecificData(data, size);
+            }
         }
 #endif
     } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_MPEG, mMIME)) {
@@ -1171,6 +1267,9 @@ static size_t getFrameSize(
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
+#ifdef STE_HARDWARE
+        case 0x7FA00000: //OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB
+#endif
         /*
         * FIXME: For the Opaque color format, the frame size does not
         * need to be (w*h*3)/2. It just needs to
@@ -1655,6 +1754,9 @@ status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
     if (ExtendedUtils::isAVCProfileSupported(h264type.eProfile)){
         ALOGI("Profile type is  %d ",h264type.eProfile);
     } else if (h264type.eProfile != OMX_VIDEO_AVCProfileBaseline) {
+#elif defined (STE_HARDWARE)
+    if ((h264type.eProfile != OMX_VIDEO_AVCProfileBaseline) &&
+        (!(mQuirks & kOverrideDefaultAVCProfile))) {
 #else
     if (h264type.eProfile != OMX_VIDEO_AVCProfileBaseline) {
 #endif
@@ -1746,8 +1848,13 @@ status_t OMXCodec::setVideoOutputFormat(
                 return err;
             }
             compressionFormat = OMX_VIDEO_CodingRV;
+#ifdef STE_HARDWARE
+	} else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VC1, mime)) {
+            compressionFormat = OMX_VIDEO_CodingWMV;
+#else
         } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VC1, mime)) {
             compressionFormat = OMX_VIDEO_CodingVC1;
+#endif
         } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_FLV1, mime)) {
             compressionFormat = OMX_VIDEO_CodingFLV1;
         } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime)) {
@@ -2008,6 +2115,8 @@ void OMXCodec::setComponentRole(
             "audio_decoder.aac", "audio_encoder.aac" },
         { MEDIA_MIMETYPE_AUDIO_VORBIS,
             "audio_decoder.vorbis", "audio_encoder.vorbis" },
+        { MEDIA_MIMETYPE_AUDIO_WMA,
+            "audio_decoder.wmapro", "audio_encoder.wmapro" },
         { MEDIA_MIMETYPE_AUDIO_G711_MLAW,
             "audio_decoder.g711mlaw", "audio_encoder.g711mlaw" },
         { MEDIA_MIMETYPE_AUDIO_G711_ALAW,
@@ -2034,6 +2143,10 @@ void OMXCodec::setComponentRole(
             "audio_decoder.flac", "audio_encoder.flac" },
         { MEDIA_MIMETYPE_AUDIO_MSGSM,
             "audio_decoder.gsm", "audio_encoder.gsm" },
+#ifdef STE_HARDWARE
+        { MEDIA_MIMETYPE_VIDEO_VC1,
+            "video_decoder.vc1", "video_encoder.vc1" },
+#endif
     };
 
     static const size_t kNumMimeToRole =
@@ -2119,6 +2232,16 @@ status_t OMXCodec::init() {
     CHECK_EQ((int)mState, (int)LOADED);
 
     status_t err;
+#ifdef STE_HARDWARE
+    if ((mQuirks & kRequiresStoreMetaDataBeforeIdle)
+        && (mFlags & kStoreMetaDataInVideoBuffers)) {
+        err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
+        if (err != OK) {
+            ALOGE("Storing meta data in video buffers is not supported");
+            return err;
+        }
+    }
+#endif
     if (!(mQuirks & kRequiresLoadedToIdleAfterAllocation)) {
         err = mOMX->sendCommand(mNode, OMX_CommandStateSet, OMX_StateIdle);
         CHECK_EQ(err, (status_t)OK);
@@ -2190,7 +2313,13 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
     }
 
     status_t err = OK;
+#ifdef STE_HARDWARE
+    if (!(mQuirks & kRequiresStoreMetaDataBeforeIdle)
+            && (mFlags & kStoreMetaDataInVideoBuffers)
+#else
     if ((mFlags & kStoreMetaDataInVideoBuffers)
+#endif
+            && (mFlags & kStoreMetaDataInVideoBuffers)
             && portIndex == kPortIndexInput) {
         err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
         if (err != OK) {
@@ -5714,6 +5843,9 @@ static const char *audioCodingTypeString(OMX_AUDIO_CODINGTYPE type) {
         "OMX_AUDIO_CodingRA",
         "OMX_AUDIO_CodingMIDI",
         "OMX_AUDIO_CodingFLAC",
+#ifdef STE_HARDWARE
+        "OMX_AUDIO_CodingWMAPRO",
+#endif
 #ifdef DOLBY_UDC
         "OMX_AUDIO_CodingDDP",
 #endif // DOLBY_UDC
@@ -6097,6 +6229,9 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
             } else if (video_def->eCompressionFormat == OMX_VIDEO_CodingAVC) {
                 mOutputFormat->setCString(
                         kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_AVC);
+            } else if (video_def->eCompressionFormat == OMX_VIDEO_CodingWMV) {
+                mOutputFormat->setCString(
+                        kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_VC1);
             } else {
                 CHECK(!"Unknown compression format.");
             }
diff --git a/media/libstagefright/PCMExtractor.cpp b/media/libstagefright/PCMExtractor.cpp
new file mode 100644
index 0000000..bb26bcd
--- /dev/null
+++ b/media/libstagefright/PCMExtractor.cpp
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Andreas Gustafsson (andreas.a.gustafsson@stericsson.com)
+ *         for ST-Ericsson
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "PCMExtractor"
+#include <utils/Log.h>
+
+#include "include/PCMExtractor.h"
+
+#include <media/stagefright/MediaBufferGroup.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/foundation/ADebug.h>
+
+namespace android {
+
+/**
+* The default buffer size.
+*/
+static const uint16_t kDefaultNumChannels = 2;
+
+/**
+* The default Sample rate.
+*/
+static const uint32_t kDefaultSampleRate = 48000;
+
+/**
+* Bits per sample.
+*/
+static const uint16_t kDefaultBitsPerSample = 16;
+
+/**
+* The default buffer size.
+*/
+static const uint32_t kDefaultBufferSize = 4800;
+
+/**
+* Buffer duration in ms, to be used for input
+*/
+static const uint16_t kInputBufferDuration = 64;
+
+/**
+* Buffer granulairity in samples to be used for input.
+*/
+static const uint16_t kBufferGranularityInSamples = 16;
+
+struct PCMSource : public MediaSource {
+    PCMSource(
+            const sp<DataSource> &dataSource,
+            const sp<MetaData> &meta,
+            int32_t bitsPerSample,
+            off_t offset, size_t size);
+
+    virtual status_t start(MetaData *params = NULL);
+    virtual status_t stop();
+    virtual sp<MetaData> getFormat();
+
+    virtual status_t read(
+            MediaBuffer **buffer, const ReadOptions *options = NULL);
+
+protected:
+    virtual ~PCMSource();
+
+private:
+    static const size_t kMaxFrameSize;
+
+    sp<DataSource> mDataSource;
+    sp<MetaData> mMeta;
+    int32_t mSampleRate;
+    int32_t mNumChannels;
+    int32_t mBitsPerSample;
+    off_t mOffset;
+    size_t mSize;
+    bool mStarted;
+    MediaBufferGroup *mGroup;
+    off_t mCurrentPos;
+    uint32_t mBufferSize;
+
+    DISALLOW_EVIL_CONSTRUCTORS(PCMSource);
+};
+
+PCMExtractor::PCMExtractor(const sp<DataSource> &source)
+    : mDataSource(source),
+      mValidFormat(false) {
+    mInitCheck = init();
+}
+
+PCMExtractor::~PCMExtractor() {
+}
+
+sp<MetaData> PCMExtractor::getMetaData() {
+    sp<MetaData> meta = new MetaData;
+
+    if (mInitCheck != OK) {
+        return meta;
+    }
+
+    meta->setCString(kKeyMIMEType, "audio/raw");
+
+    return meta;
+}
+
+size_t PCMExtractor::countTracks() {
+    return mInitCheck == OK ? 1 : 0;
+}
+
+sp<MediaSource> PCMExtractor::getTrack(size_t index) {
+    if (mInitCheck != OK || index > 0) {
+        return NULL;
+    }
+
+    return new PCMSource(
+            mDataSource, mTrackMeta,
+            kDefaultBitsPerSample, mDataOffset, mDataSize);
+}
+
+sp<MetaData> PCMExtractor::getTrackMetaData(
+        size_t index, uint32_t flags) {
+    if (mInitCheck != OK || index > 0) {
+        return NULL;
+    }
+
+    return mTrackMeta;
+}
+
+status_t PCMExtractor::init() {
+    mDataOffset = 0;
+    mDataSize = 0;
+    mValidFormat = true;
+    mTrackMeta = new MetaData;mTrackMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
+    mTrackMeta->setInt32(kKeyChannelCount, kDefaultNumChannels);
+    mTrackMeta->setInt32(kKeySampleRate, kDefaultSampleRate);
+    return OK;
+}
+
+const size_t PCMSource::kMaxFrameSize = 4800;
+
+PCMSource::PCMSource(
+        const sp<DataSource> &dataSource,
+        const sp<MetaData> &meta,
+        int32_t bitsPerSample,
+        off_t offset, size_t size)
+    : mDataSource(dataSource),
+      mMeta(meta),
+      mSampleRate(0),
+      mNumChannels(0),
+      mBitsPerSample(bitsPerSample),
+      mOffset(offset),
+      mSize(size),
+      mStarted(false),
+      mGroup(NULL),
+      mBufferSize(0) {
+    CHECK(mMeta->findInt32(kKeySampleRate, &mSampleRate));
+    CHECK(mMeta->findInt32(kKeyChannelCount, &mNumChannels));
+}
+
+PCMSource::~PCMSource() {
+    if (mStarted) {
+        stop();
+    }
+}
+
+status_t PCMSource::start(MetaData *params) {
+    CHECK(!mStarted);
+
+    size_t size = kDefaultBufferSize;
+
+    if (mSampleRate != 0 && mNumChannels != 0) {
+        mBufferSize = mSampleRate * kInputBufferDuration / 1000 * mNumChannels * 2;
+        size_t granularity = kBufferGranularityInSamples * 2 * mNumChannels;
+        mBufferSize = (mBufferSize / granularity) * granularity;
+    }
+    mGroup = new MediaBufferGroup;
+    mGroup->add_buffer(new MediaBuffer(mBufferSize));
+
+    if (mBitsPerSample == 8) {
+        // As a temporary buffer for 8->16 bit conversion.
+        mGroup->add_buffer(new MediaBuffer(mBufferSize));
+    }
+
+    mCurrentPos = mOffset;
+
+    mStarted = true;
+    return OK;
+}
+
+status_t PCMSource::stop() {
+
+    CHECK(mStarted);
+    delete mGroup;
+    mGroup = NULL;
+
+    mStarted = false;
+    return OK;
+}
+
+sp<MetaData> PCMSource::getFormat() {
+   return mMeta;
+}
+
+status_t PCMSource::read(
+        MediaBuffer **out, const ReadOptions *options) {
+    *out = NULL;
+    int64_t seekTimeUs;
+    ReadOptions::SeekMode seek = ReadOptions::SEEK_CLOSEST_SYNC;
+    if (options != NULL && options->getSeekTo(&seekTimeUs,&seek)) {
+        int64_t pos = (seekTimeUs * mSampleRate) / 1000000 * mNumChannels * 2;
+        if (pos > mSize) {
+            pos = mSize;
+        }
+        mCurrentPos = pos + mOffset;
+    }
+
+    MediaBuffer *buffer;
+    status_t err = mGroup->acquire_buffer(&buffer);
+    if (err != OK) {
+        return err;
+    }
+
+    ssize_t n = mDataSource->readAt(
+            mCurrentPos, buffer->data(), mBufferSize);
+    if (n <= 0) {
+        buffer->release();
+        buffer = NULL;
+        return ERROR_END_OF_STREAM;
+    }
+
+    mCurrentPos += n;
+
+    buffer->set_range(0, n);
+
+    if (mBitsPerSample == 8) {
+        // Convert 8-bit unsigned samples to 16-bit signed.
+
+        MediaBuffer *tmp;
+        CHECK_EQ(mGroup->acquire_buffer(&tmp), (status_t)OK);
+
+        // The new buffer holds the sample number of samples, but each
+        // one is 2 bytes wide.
+        tmp->set_range(0, 2 * n);
+
+        int16_t *dst = (int16_t *)tmp->data();
+        const uint8_t *src = (const uint8_t *)buffer->data();
+        while (n-- > 0) {
+            *dst++ = ((int16_t)(*src) - 128) * 256;
+            ++src;
+        }
+
+        buffer->release();
+        buffer = tmp;
+    } else if (mBitsPerSample == 24) {
+        // Convert 24-bit signed samples to 16-bit signed.
+
+        const uint8_t *src =
+            (const uint8_t *)buffer->data() + buffer->range_offset();
+        int16_t *dst = (int16_t *)src;
+
+        size_t numSamples = buffer->range_length() / 3;
+        for (size_t i = 0; i < numSamples; ++i) {
+            int32_t x = (int32_t)(src[0] | src[1] << 8 | src[2] << 16);
+            x = (x << 8) >> 8;  // sign extension
+
+            x = x >> 8;
+            *dst++ = (int16_t)x;
+            src += 3;
+        }
+
+        buffer->set_range(buffer->range_offset(), 2 * numSamples);
+    }
+
+    size_t bytesPerSample = mBitsPerSample >> 3;
+
+    buffer->meta_data()->setInt64(
+            kKeyTime,
+            1000000LL * (mCurrentPos - mOffset)
+                / (mNumChannels * bytesPerSample) / mSampleRate);
+
+
+    *out = buffer;
+
+    return OK;
+}
+
+}  // namespace android
diff --git a/media/libstagefright/SampleTable.cpp b/media/libstagefright/SampleTable.cpp
index 2bb47a5..a777032 100644
--- a/media/libstagefright/SampleTable.cpp
+++ b/media/libstagefright/SampleTable.cpp
@@ -350,7 +350,7 @@ status_t SampleTable::setTimeToSampleParams(
 }
 
 status_t SampleTable::setCompositionTimeToSampleParams(
-        off64_t data_offset, size_t data_size) {
+        off64_t data_offset, size_t data_size, uint32_t *consumed_offset) {
     ALOGI("There are reordered frames present.");
 
     if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {
@@ -372,7 +372,7 @@ status_t SampleTable::setCompositionTimeToSampleParams(
 
     size_t numEntries = U32_AT(&header[4]);
 
-    if (data_size != (numEntries + 1) * 8) {
+    if (data_size < (numEntries + 1) * 8) {
         return ERROR_MALFORMED;
     }
 
@@ -400,6 +400,7 @@ status_t SampleTable::setCompositionTimeToSampleParams(
     mCompositionDeltaLookup->setEntries(
             mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);
 
+    *consumed_offset = (numEntries + 1) * 8;
     return OK;
 }
 
diff --git a/media/libstagefright/StagefrightMetadataRetriever.cpp b/media/libstagefright/StagefrightMetadataRetriever.cpp
index b6752b9..897be9e 100644
--- a/media/libstagefright/StagefrightMetadataRetriever.cpp
+++ b/media/libstagefright/StagefrightMetadataRetriever.cpp
@@ -18,6 +18,8 @@
 #define LOG_TAG "StagefrightMetadataRetriever"
 #include <utils/Log.h>
 
+#include <sys/stat.h>
+
 #include "include/StagefrightMetadataRetriever.h"
 
 #include <media/stagefright/foundation/ADebug.h>
@@ -83,7 +85,21 @@ status_t StagefrightMetadataRetriever::setDataSource(
         int fd, int64_t offset, int64_t length) {
     fd = dup(fd);
 
-    ALOGV("setDataSource(%d, %lld, %lld)", fd, offset, length);
+    // Get uri from fd (debug)
+    char uri[256];
+    snprintf(uri, sizeof(uri), "fd=%d", fd);// At least fd is traced
+
+    char buffer[256];
+    snprintf(buffer, sizeof(buffer), "/proc/%d/fd/%d", gettid(), fd);
+    struct stat s;
+    if (lstat(buffer, &s) == 0) {
+        if ((s.st_mode & S_IFMT) == S_IFLNK) {
+            int len = readlink(buffer, uri, sizeof(uri));// Get uri from link
+            uri[len] = 0;
+        }
+    }
+
+    ALOGV("setDataSource(%d, %lld, %lld, %s)", fd, offset, length, uri);
 
     mParsedMetaData = false;
     mMetaData.clear();
@@ -94,6 +110,8 @@ status_t StagefrightMetadataRetriever::setDataSource(
 
     status_t err;
     if ((err = mSource->initCheck()) != OK) {
+        ALOGE("Unable to create data source for '%s'.", uri);
+
         mSource.clear();
 
         return err;
@@ -102,11 +120,16 @@ status_t StagefrightMetadataRetriever::setDataSource(
     mExtractor = MediaExtractor::Create(mSource);
 
     if (mExtractor == NULL) {
+        ALOGE("Unable to instantiate an extractor for '%s'.", uri);
+
         mSource.clear();
 
         return UNKNOWN_ERROR;
     }
 
+    // Stamp source with uri (debug)
+    mSource->setCharUri(uri);
+
     return OK;
 }
 
@@ -346,20 +369,22 @@ VideoFrame *StagefrightMetadataRetriever::getFrameAtTime(
     ALOGV("getFrameAtTime: %lld us option: %d", timeUs, option);
 
     if (mExtractor.get() == NULL) {
-        ALOGV("no extractor.");
+        ALOGW("no extractor.");
         return NULL;
     }
 
     sp<MetaData> fileMeta = mExtractor->getMetaData();
 
     if (fileMeta == NULL) {
-        ALOGV("extractor doesn't publish metadata, failed to initialize?");
+        ALOGW("extractor doesn't publish metadata for %s , failed to initialize?",
+             mSource->getCharUri());
         return NULL;
     }
 
     int32_t drm = 0;
     if (fileMeta->findInt32(kKeyIsDRM, &drm) && drm != 0) {
-        ALOGE("frame grab not allowed.");
+        ALOGE("frame grab not allowed. Failed to extract thumbnail for %s",
+             mSource->getCharUri());
         return NULL;
     }
 
@@ -377,7 +402,8 @@ VideoFrame *StagefrightMetadataRetriever::getFrameAtTime(
     }
 
     if (i == n) {
-        ALOGV("no video track found.");
+        ALOGW("no video track found. Failed to extract thumbnail for %s",
+             mSource->getCharUri());
         return NULL;
     }
 
@@ -387,7 +413,9 @@ VideoFrame *StagefrightMetadataRetriever::getFrameAtTime(
     sp<MediaSource> source = mExtractor->getTrack(i);
 
     if (source.get() == NULL) {
-        ALOGV("unable to instantiate video track.");
+        ALOGW("unable to instantiate video track. "
+             "Failed to extract thumbnail for %s",
+             mSource->getCharUri());
         return NULL;
     }
 
@@ -412,11 +440,22 @@ VideoFrame *StagefrightMetadataRetriever::getFrameAtTime(
                 timeUs, option);
 
     if (frame == NULL) {
-        ALOGV("Software decoder failed to extract thumbnail, "
-             "trying hardware decoder.");
+        ALOGV("Software decoder failed to extract thumbnail for %s, "
+             "trying hardware decoder.", mSource->getCharUri());
 
         frame = extractVideoFrameWithCodecFlags(&mClient, trackMeta, source, 0,
                         timeUs, option);
+
+        if (frame == NULL) {
+            ALOGE("Hardware decoder failed to extract thumbnail for %s",
+                 mSource->getCharUri());
+        } else {
+            ALOGV("Hardware decoder succeeded to extract thumbnail for %s",
+                 mSource->getCharUri());
+        }
+    } else {
+        ALOGV("Software decoder succeeded to extract thumbnail for %s",
+             mSource->getCharUri());
     }
 
     return frame;
diff --git a/media/libstagefright/SurfaceMediaSource.cpp b/media/libstagefright/SurfaceMediaSource.cpp
index 3a8d755..59a26e2 100644
--- a/media/libstagefright/SurfaceMediaSource.cpp
+++ b/media/libstagefright/SurfaceMediaSource.cpp
@@ -33,6 +33,15 @@
 
 #include <private/gui/ComposerService.h>
 
+#include <ui/GraphicBufferMapper.h>
+#include <ui/Region.h>
+#include <hardware/hardware.h>
+#include <ui/PixelFormat.h>
+
+#include <cutils/properties.h>
+
+#define STE_ENCODER_COLOR_FORMAT "ste.video.enc.fmt"
+
 namespace android {
 
 SurfaceMediaSource::SurfaceMediaSource(uint32_t bufferWidth, uint32_t bufferHeight) :
@@ -58,9 +67,13 @@ SurfaceMediaSource::SurfaceMediaSource(uint32_t bufferWidth, uint32_t bufferHeig
     mBufferQueue = new BufferQueue();
     mBufferQueue->setDefaultBufferSize(bufferWidth, bufferHeight);
     mBufferQueue->setConsumerUsageBits(GRALLOC_USAGE_HW_VIDEO_ENCODER |
-            GRALLOC_USAGE_HW_TEXTURE);
+            GRALLOC_USAGE_HW_2D);
 
     sp<ISurfaceComposer> composer(ComposerService::getComposerService());
+    mGraphicBufferAlloc = composer->createGraphicBufferAlloc();
+    if (mGraphicBufferAlloc == NULL) {
+        ALOGE("createGraphicBufferAlloc() failed in SurfaceMediaSource");
+    }
 
     // Note that we can't create an sp<...>(this) in a ctor that will not keep a
     // reference once the ctor ends, as that would cause the refcount of 'this'
@@ -393,10 +406,15 @@ void SurfaceMediaSource::signalBufferReturned(MediaBuffer *buffer) {
     Mutex::Autolock lock(mMutex);
 
     buffer_handle_t bufferHandle = getMediaBufferHandle(buffer);
+    buffer_handle_t graphicbufferHandle = NULL;
 
     for (size_t i = 0; i < mCurrentBuffers.size(); i++) {
         if (mCurrentBuffers[i]->handle == bufferHandle) {
             mCurrentBuffers.removeAt(i);
+            if (mCurrentBuffersDQ.itemAt(i) != NULL) {
+                graphicbufferHandle = mCurrentBuffersDQ.itemAt(i)->handle;
+                mCurrentBuffersDQ.removeAt(i);
+            }
             foundBuffer = true;
             break;
         }
diff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp
index 1577cda..11979d1 100644
--- a/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -58,13 +58,15 @@ bool ColorConverter::isValid() const {
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
+#ifdef STE_HARDWARE
+        case 0x7FA00000: //OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB
 #ifdef MTK_HARDWARE
         case OMX_MTK_COLOR_FormatYV12:
         case OMX_COLOR_FormatVendorMTKYUV:
         case OMX_COLOR_FormatVendorMTKYUV_FCM:
 #endif
             return true;
-
+#endif
         default:
             return false;
     }
@@ -125,6 +127,11 @@ status_t ColorConverter::convert(
             err = convertYUV420Planar(src, dst);
 #endif
             break;
+#ifdef STE_HARDWARE
+        case 0x7FA00000: //OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB
+            err = convertSTEYUV420PackedSemiPlanarMB(src, dst);
+            break;
+#endif
 
         case OMX_COLOR_FormatCbYCrY:
             err = convertCbYCrY(src, dst);
@@ -534,6 +541,145 @@ status_t ColorConverter::convertTIYUV420PackedSemiPlanar(
     return OK;
 }
 
+#ifdef STE_HARDWARE
+status_t ColorConverter::convertSTEYUV420PackedSemiPlanarMB(
+        const BitmapParams &src, const BitmapParams &dst) {
+
+    if (!((dst.mWidth & 1) == 0
+            && src.mCropLeft == 0
+            && src.mCropTop == 0
+            && src.cropWidth() == dst.cropWidth()
+            && src.cropHeight() == dst.cropHeight())) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    OMX_U32 mx = src.mWidth / 16;
+    OMX_U32 my = src.mHeight / 16;
+    OMX_U32 lx, ly;
+    OMX_U32 *pChroma, *pLuma = (OMX_U32 *)src.mBits;
+
+    pChroma = (OMX_U32 *)src.mBits + mx * my * 64;
+    for (ly = 0; ly < my; ly++) {
+        for (lx = 0; lx < mx; lx++) {
+            OMX_U32 col, row, lumaWord, chromaWord1 = 0, rgbWord, i;
+            OMX_U8 y[4], cb[4], cr[4], r[4], g[4], b[4];
+            OMX_U32 *dstBuf, *locBuf;
+            OMX_U32 *pBurstLuma = 0, *pBurstChroma = 0;
+            OMX_U32 *pWordLuma = 0, *pWordChroma = 0;
+            OMX_U8 nbOfBlock;
+
+            dstBuf = ((OMX_U32 *)dst.mBits) + (ly * 16) * dst.mWidth / 2;
+            dstBuf += (lx * 16) / 2;
+
+            pBurstLuma = pLuma;
+            pBurstChroma = pChroma;
+
+            for (col = 0; col < 2; col++) {
+                // conversion of a macroblock
+                for (nbOfBlock = 0; nbOfBlock < 2; nbOfBlock++) {
+                    locBuf = dstBuf + 4 * col + 2 * nbOfBlock;
+                    OMX_U32 dstRowOrigo = ly * 16 * dst.mWidth;
+
+                    switch (nbOfBlock) {
+                    case 0:
+                        pWordLuma = pBurstLuma;
+                        pWordChroma = pBurstChroma;
+                        break;
+                    case 1:
+                        pWordLuma = pBurstLuma + 1;
+                        pWordChroma = pBurstChroma + 1;
+                        break;
+                    }
+                    for (row = 0; row < 16; row++) {
+
+                        // Check for cropping on the y axis
+                        if (ly * 16 + row >= dst.mHeight) {
+                            break;
+                        }
+
+                        lumaWord = *pWordLuma;
+                        pWordLuma += 2;
+                        if (row % 2 == 0) {
+                            chromaWord1 = *pWordChroma;
+                            pWordChroma += 2;
+                        }
+
+                        y[3] = ((lumaWord >> 24) & 0xff);
+                        y[2] = ((lumaWord >> 16) & 0xff);
+                        y[1] = ((lumaWord >>  8) & 0xff);
+                        y[0] = ((lumaWord >>  0) & 0xff);
+
+                        cb[0] = cb[1] = ((chromaWord1 >>  0) & 0xff);
+                        cb[2] = cb[3] = ((chromaWord1 >> 16) & 0xff);
+                        cr[0] = cr[1] = ((chromaWord1 >>  8) & 0xff);
+                        cr[2] = cr[3] = ((chromaWord1 >> 24) & 0xff);
+
+                        for (i = 0; i < 4; i++) {
+
+                            int32_t rW,gW,bW;
+
+                            rW = 298 * y[i] + 408 * cr[i] - 57059;
+                            gW = 298 * y[i] - 100 * cb[i] - 208 * cr[i] + 34713;
+                            bW = 298 * y[i] + 516 * cb[i] - 70887;
+
+                            if (rW < 0) {
+                                r[i] = 0;
+                            } else if (rW >= 65536) {
+                                r[i] = 255;
+                            } else {
+                                r[i] = (rW >> 8);
+                            }
+                            if (gW < 0) {
+                                g[i] = 0;
+                            } else if (gW >= 65536) {
+                                g[i] = 255;
+                            } else {
+                                g[i] = (gW >> 8);
+                            }
+                            if (bW < 0) {
+                                b[i] = 0;
+                            } else if (bW >= 65536) {
+                                b[i] = 255;
+                            } else {
+                                b[i] = (bW >> 8);
+                            }
+                            r[i] >>= 3;
+                            g[i] >>= 2;
+                            b[i] >>= 3;
+                        }
+                        for (i = 0; i < 4; i += 2) {
+
+                            // Check for cropping on the x axis
+                            OMX_U32 rowPos = (locBuf - (OMX_U32 *)dst.mBits) * 2 - dstRowOrigo;
+                            if (rowPos >= dst.mWidth) {
+                                locBuf++;
+                                continue;
+                            }
+
+                            rgbWord = (r[i + 1] << 27) +
+                                (g[i + 1] << 21) +
+                                (b[i + 1] << 16) +
+                                (r[i] << 11) +
+                                (g[i] << 5) +
+                                (b[i] << 0);
+                            *locBuf++ = rgbWord;
+                        }
+                        locBuf += dst.mWidth / 2 - 2;
+                        dstRowOrigo += dst.mWidth;
+                    } //end of for 16 loop
+                }  //end of 2 block loop
+                pBurstLuma += 32;
+                pBurstChroma += 16;
+            } // end of 2 col loop
+            pLuma   += 64;
+            pChroma += 32;
+        }
+    }
+
+    return OK;
+}
+#endif
+
 uint8_t *ColorConverter::initClip() {
     static const signed kClipMin = -278;
     static const signed kClipMax = 535;
diff --git a/media/libstagefright/foundation/ABitReader.cpp b/media/libstagefright/foundation/ABitReader.cpp
index 5499c32..5d31786 100644
--- a/media/libstagefright/foundation/ABitReader.cpp
+++ b/media/libstagefright/foundation/ABitReader.cpp
@@ -22,7 +22,9 @@ namespace android {
 
 ABitReader::ABitReader(const uint8_t *data, size_t size)
     : mData(data),
+      mOriginalData(data),
       mSize(size),
+      mOriginalSize(size),
       mReservoir(0),
       mNumBitsLeft(0) {
 }
@@ -78,6 +80,19 @@ void ABitReader::skipBits(size_t n) {
     }
 }
 
+void ABitReader::rewindBits(size_t n) {
+    CHECK_GE(mOriginalSize * 8 - numBitsLeft(), n);
+
+    size_t bitsLeft = numBitsLeft();
+
+    mData = mOriginalData;
+    mSize = mOriginalSize;
+    mReservoir = 0;
+    mNumBitsLeft = 0;
+
+    skipBits(mOriginalSize * 8 - bitsLeft - n);
+}
+
 void ABitReader::putBits(uint32_t x, size_t n) {
     CHECK_LE(n, 32u);
 
diff --git a/media/libstagefright/include/ASFExtractor.h b/media/libstagefright/include/ASFExtractor.h
new file mode 100644
index 0000000..1f7c59b
--- /dev/null
+++ b/media/libstagefright/include/ASFExtractor.h
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ASF_EXTRACTOR_H_
+#define ASF_EXTRACTOR_H_
+
+#include <media/stagefright/foundation/ABase.h>
+#include <media/stagefright/MediaExtractor.h>
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/Utils.h>
+#include <utils/Vector.h>
+#include "asf.h"
+
+namespace android {
+
+///////////////////////////////////////////////////////////////////////////////
+// Function Pointer Declaration
+typedef int (*asf_init_function)(asf_file_t *);
+typedef int (*asf_get_packet_function)(asf_file_t *, asf_packet_t *);
+typedef int64_t (*asf_seek_to_msec_function)(asf_file_t *, int64_t);
+typedef asf_packet_t * (*asf_packet_create_function)();
+typedef int (*asf_packet_destroy_function)(asf_packet_t *);
+typedef asf_stream_t *(*asf_get_stream_function)(asf_file_t *, int);
+typedef void (*asf_close_function)(asf_file_t *);
+
+struct ASFExtractor : public MediaExtractor {
+    ASFExtractor(const sp<DataSource> &dataSource);
+
+    virtual size_t countTracks();
+
+    virtual sp<MediaSource> getTrack(size_t index);
+
+    virtual sp<MetaData> getTrackMetaData(
+            size_t index, uint32_t flags);
+
+    virtual sp<MetaData> getMetaData();
+    sp<DataSource> mDataSource;
+    void *mLibAsfHandle;
+protected:
+    virtual ~ASFExtractor();
+
+private:
+    struct ASFSource;
+
+    struct SampleInfo {
+        uint32_t mOffset;
+        bool mIsKey;
+    };
+
+    struct Track {
+        sp<MetaData> mMeta;
+        Vector<SampleInfo> mSamples;
+
+        enum Kind {
+            AUDIO,
+            VIDEO,
+            OTHER
+
+        } mKind;
+
+        size_t mNumSyncSamples;
+        size_t mThumbnailSampleSize;
+        ssize_t mThumbnailSampleIndex;
+        size_t mMaxSampleSize;
+
+        double mAvgChunkSize;
+        size_t mFirstChunkSize;
+        asf_stream_type_t mStreamNumber;
+    };
+
+    status_t mInitCheck;
+    Vector<Track> mTracks;
+    asf_file_t *mFileHandle;
+    int32_t mDataPacketPosition;
+    bool mIsVC1AdvancedProfile;
+
+    enum TrackTypes {
+        AUDIO_TRACK,
+        VIDEO_TRACK
+    } mTrackType;
+
+    mutable Mutex mLock;
+
+    ssize_t parseChunk(off64_t offset, off64_t size, int depth = 0);
+    status_t parseStreamHeader(off64_t offset, size_t size);
+    status_t parseStreamFormat(off64_t offset, size_t size);
+    status_t parseIndex(off64_t offset, size_t size);
+
+    status_t parseHeaders();
+
+    status_t getPacket(asf_file_t *mFileHandle, asf_packet_t *mPacket);
+
+    status_t getSampleTime(
+            size_t trackIndex, size_t sampleIndex, int64_t *sampleTimeUs);
+
+    status_t getSampleIndexAtTime(asf_file_t *mfileHandle, int64_t timeUs);
+
+    status_t addMPEG4CodecSpecificData(size_t trackIndex);
+    status_t addH264CodecSpecificData(size_t trackIndex);
+    status_t addVC1CodecSpecificData(asf_bitmapinfoheader_t *bmp, sp<MetaData> meta);
+    status_t addWMACodecSpecificData(asf_waveformatex_t *wav, sp<MetaData> meta);
+
+    static bool IsCorrectChunkType(
+        ssize_t trackIndex, Track::Kind kind, uint32_t chunkType);
+    asf_file_t* asfOpenConfigure();
+    asf_file_t* asfOpenCb(asf_iostream_t *iostream);
+
+    /////////////////////////////////////////////////////////////////////
+    // ASF Library function pointers
+    asf_init_function           libasf_init;
+    asf_get_packet_function     libasf_get_packet;
+    asf_seek_to_msec_function   libasf_seek_to_msec;
+    asf_packet_create_function  libasf_packet_create;
+    asf_packet_destroy_function libasf_packet_destroy;
+    asf_get_stream_function     libasf_get_stream;
+    asf_close_function          libasf_close;
+
+    DISALLOW_EVIL_CONSTRUCTORS(ASFExtractor);
+
+};
+
+bool SniffASF(
+        const sp<DataSource> &source, String8 *mimeType, float *confidence,
+        sp<AMessage> *);
+
+}  // namespace android
+
+#endif  // ASF_EXTRACTOR_H_
diff --git a/media/libstagefright/include/AVIExtractor.h b/media/libstagefright/include/AVIExtractor.h
index 734fe05..7bd994a 100644
--- a/media/libstagefright/include/AVIExtractor.h
+++ b/media/libstagefright/include/AVIExtractor.h
@@ -43,6 +43,8 @@ struct AVIExtractor : public MediaExtractor {
 
 protected:
     virtual ~AVIExtractor();
+    bool mIsVC1SimpleProfile;
+    bool mIsVC1AdvancedProfile;
 
 private:
     struct AVISource;
@@ -76,6 +78,9 @@ private:
         ssize_t mThumbnailSampleIndex;
         size_t mMaxSampleSize;
 
+        uint8_t extraData[4]; // To store the STRUCT_C from AVI container
+        uint8_t *apExtraData; // To store the Sequence header content
+        uint32_t apExtraDataSize; // Size of the extra data stored
         // If mBytesPerSample > 0:
         double mAvgChunkSize;
         size_t mFirstChunkSize;
@@ -111,6 +116,7 @@ private:
 
     status_t addMPEG4CodecSpecificData(size_t trackIndex);
     status_t addH264CodecSpecificData(size_t trackIndex);
+    status_t addVC1CodecSpecificData(size_t trackIndex);
 
     static bool IsCorrectChunkType(
         ssize_t trackIndex, Track::Kind kind, uint32_t chunkType);
diff --git a/media/libstagefright/include/NuCachedFileSource2.h b/media/libstagefright/include/NuCachedFileSource2.h
new file mode 100644
index 0000000..d0817d7
--- /dev/null
+++ b/media/libstagefright/include/NuCachedFileSource2.h
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NU_CACHED_FILE_SOURCE_2_H_
+
+#define NU_CACHED_FILE_SOURCE_2_H_
+
+#include <media/stagefright/foundation/ABase.h>
+#include <media/stagefright/foundation/AHandlerReflector.h>
+#include <media/stagefright/DataSource.h>
+
+namespace android {
+
+struct ALooper;
+struct PageFileCache;
+
+struct NuCachedFileSource2 : public DataSource {
+    NuCachedFileSource2(
+            const sp<DataSource> &source,
+            const char *cacheConfig = NULL,
+            bool disconnectAtHighwatermark = false);
+
+    virtual status_t initCheck() const;
+
+    virtual ssize_t readAt(off64_t offset, void *data, size_t size);
+
+    virtual status_t getSize(off64_t *size);
+    virtual uint32_t flags();
+
+    virtual sp<DecryptHandle> DrmInitialization(const char* mime);
+    virtual void getDrmInfo(sp<DecryptHandle> &handle, DrmManagerClient **client);
+    virtual String8 getUri();
+
+    virtual String8 getMIMEType() const;
+
+    ////////////////////////////////////////////////////////////////////////////
+
+    size_t cachedSize();
+    size_t approxDataRemaining(status_t *finalStatus) const;
+
+    void resumeFetchingIfNecessary();
+
+    // The following methods are supported only if the
+    // data source is HTTP-based; otherwise, ERROR_UNSUPPORTED
+    // is returned.
+    status_t getEstimatedBandwidthKbps(int32_t *kbps);
+    status_t setCacheStatCollectFreq(int32_t freqMs);
+
+    static void RemoveCacheSpecificHeaders(
+            KeyedVector<String8, String8> *headers,
+            String8 *cacheConfig,
+            bool *disconnectAtHighwatermark);
+
+protected:
+    virtual ~NuCachedFileSource2();
+
+private:
+    friend struct AHandlerReflector<NuCachedFileSource2>;
+
+    enum {
+        kPageSize                       = 65536,
+        kDefaultHighWaterThreshold      = 5 * 1024 * 1024,
+        kDefaultLowWaterThreshold       = 512 * 1024,
+
+        // Read data after a 15 sec timeout whether we're actively
+        // fetching or not.
+        kDefaultKeepAliveIntervalUs     = 15000000,
+        kFetchIntervalUs         = 100000ll,
+        kFetchDeferredIntervalUs = 10000ll,
+
+        kBypassCacheCheckTrigger = 100,
+        kBypassCacheDuration     = 1000,
+        kBypassCacheThreshold    = 10 // in percent
+    };
+
+    enum {
+        kWhatFetchMore  = 'fetc',
+        kWhatRead       = 'read',
+    };
+
+    enum {
+        kMaxNumRetries = 10,
+    };
+
+    sp<DataSource> mSource;
+    sp<AHandlerReflector<NuCachedFileSource2> > mReflector;
+    sp<ALooper> mLooper;
+
+    Mutex mSerializer;
+    mutable Mutex mLock;
+    Condition mCondition;
+
+    PageFileCache *mCache;
+    off64_t mCacheOffset;
+    status_t mFinalStatus;
+    off64_t mLastAccessPos;
+    sp<AMessage> mAsyncResult;
+    bool mFetching;
+    int64_t mLastFetchTimeUs;
+    int64_t mLastFetchEventTimeUs;
+
+    int32_t mNumRetriesLeft;
+
+    size_t mHighwaterThresholdBytes;
+    size_t mLowwaterThresholdBytes;
+
+    // If the keep-alive interval is 0, keep-alives are disabled.
+    int64_t mKeepAliveIntervalUs;
+
+    bool mDisconnectAtHighwatermark;
+    unsigned int mNbrSeeks;
+    unsigned int mNbrReads;
+    bool mBypassCache;
+
+    void onMessageReceived(const sp<AMessage> &msg);
+    void onFetch();
+    void onRead(const sp<AMessage> &msg);
+
+    void fetchInternal();
+    ssize_t readInternal(off64_t offset, void *data, size_t size);
+    status_t seekInternal_l(off64_t offset);
+
+    size_t approxDataRemaining_l(status_t *finalStatus) const;
+
+    void restartPrefetcherIfNecessary_l(
+            bool ignoreLowWaterThreshold = false, bool force = false);
+
+    void updateCacheParamsFromSystemProperty();
+    void updateCacheParamsFromString(const char *s);
+
+    DISALLOW_EVIL_CONSTRUCTORS(NuCachedFileSource2);
+};
+
+}  // namespace android
+
+#endif  // NU_CACHED_FILE_SOURCE_2_H_
diff --git a/media/libstagefright/include/PCMExtractor.h b/media/libstagefright/include/PCMExtractor.h
new file mode 100644
index 0000000..4717d10
--- /dev/null
+++ b/media/libstagefright/include/PCMExtractor.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Andreas Gustafsson (andreas.a.gustafsson@stericsson.com)
+ *         for ST-Ericsson
+ */
+
+#ifndef PCM_EXTRACTOR_H_
+
+#define PCM_EXTRACTOR_H_
+
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/MediaExtractor.h>
+#include <media/stagefright/foundation/ABase.h>
+
+namespace android {
+
+class PCMExtractor : public MediaExtractor {
+public:
+    // Extractor assumes ownership of "source".
+    PCMExtractor(const sp<DataSource> &source);
+
+    virtual size_t countTracks();
+    virtual sp<MediaSource> getTrack(size_t index);
+    virtual sp<MetaData> getTrackMetaData(size_t index, uint32_t flags);
+
+    virtual sp<MetaData> getMetaData();
+
+protected:
+    virtual ~PCMExtractor();
+
+private:
+    sp<DataSource> mDataSource;
+    status_t mInitCheck;
+    bool mValidFormat;
+    off_t mDataOffset;
+    size_t mDataSize;
+    sp<MetaData> mTrackMeta;
+
+    status_t init();
+
+    DISALLOW_EVIL_CONSTRUCTORS(PCMExtractor);
+};
+
+}  // namespace android
+
+#endif  // PCM_EXTRACTOR_H_
diff --git a/media/libstagefright/include/SampleTable.h b/media/libstagefright/include/SampleTable.h
index fc5ad41..94ebd27 100644
--- a/media/libstagefright/include/SampleTable.h
+++ b/media/libstagefright/include/SampleTable.h
@@ -49,7 +49,7 @@ public:
     status_t setTimeToSampleParams(off64_t data_offset, size_t data_size);
 
     status_t setCompositionTimeToSampleParams(
-            off64_t data_offset, size_t data_size);
+            off64_t data_offset, size_t data_size, uint32_t *consumed_offset);
 
     status_t setSyncSampleParams(off64_t data_offset, size_t data_size);
 
diff --git a/media/libstagefright/include/asf.h b/media/libstagefright/include/asf.h
new file mode 100644
index 0000000..2d4a25c
--- /dev/null
+++ b/media/libstagefright/include/asf.h
@@ -0,0 +1,303 @@
+/*  libasf - An Advanced Systems Format media file parser
+ *  Copyright (C) 2006-2010 Juho Vh-Herttua
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef ASF_H
+#define ASF_H
+
+/* used int types for different platforms */
+#if defined(WIN32) && !defined(__MINGW_H)
+typedef char int8_t;
+typedef unsigned char uint8_t;
+typedef short int16_t;
+typedef unsigned short uint16_t;
+typedef long int32_t;
+typedef unsigned long uint32_t;
+
+typedef __int64 int64_t;
+typedef unsigned __int64 uint64_t;
+#else
+#include <stdint.h>
+#endif
+
+#if defined(WIN32) && defined(DLL_EXPORT)
+# define LIBASF_API __declspec(dllexport)
+#else
+# define LIBASF_API
+#endif
+
+
+
+
+typedef enum {
+	/* fatal errors related to library function */
+	ASF_ERROR_INTERNAL            = -100,  /* incorrect input to API calls */
+	ASF_ERROR_OUTOFMEM            = -101,  /* some malloc inside program failed */
+
+	/* errors related to reading data from stream */
+	ASF_ERROR_NEEDS_BYTES         = -200,  /* not enough data from read */
+	ASF_ERROR_EOF                 = -201,  /* end of file reached */
+	ASF_ERROR_IO                  = -202,  /* error reading or writing to file */
+
+	/* errors related to file being corrupted */
+	ASF_ERROR_INVALID_LENGTH      = -300,  /* length value conflict in input data */
+	ASF_ERROR_INVALID_VALUE       = -301,  /* other value conflict in input data */
+	ASF_ERROR_INVALID_OBJECT      = -302,  /* ASF object missing or in wrong place */
+	ASF_ERROR_INVALID_OBJECT_SIZE = -303,  /* invalid ASF object size (too small) */
+
+	/* errors related to seeking, usually non-fatal */
+	ASF_ERROR_SEEKABLE            = -400,  /* file not seekable */
+	ASF_ERROR_SEEK                = -401   /* file is seekable but seeking failed */
+} asf_error_t;
+
+typedef enum {
+	ASF_STREAM_TYPE_NONE     = 0x00,
+	ASF_STREAM_TYPE_AUDIO    = 0x01,
+	ASF_STREAM_TYPE_VIDEO    = 0x02,
+	ASF_STREAM_TYPE_COMMAND  = 0x03,
+	ASF_STREAM_TYPE_UNKNOWN  = 0xff
+} asf_stream_type_t;
+
+#define ASF_STREAM_FLAG_NONE       0x0000
+#define ASF_STREAM_FLAG_AVAILABLE  0x0001
+#define ASF_STREAM_FLAG_HIDDEN     0x0002
+#define ASF_STREAM_FLAG_EXTENDED   0x0004
+
+
+/* waveformatex fields specified in Microsoft documentation:
+   http://msdn2.microsoft.com/en-us/library/ms713497.aspx */
+struct asf_waveformatex_s {
+	uint16_t wFormatTag;
+	uint16_t nChannels;
+	uint32_t nSamplesPerSec;
+	uint32_t nAvgBytesPerSec;
+	uint16_t nBlockAlign;
+	uint16_t wBitsPerSample;
+	uint16_t cbSize;
+	uint8_t *data;
+};
+typedef struct asf_waveformatex_s asf_waveformatex_t;
+
+#define ASF_BITMAPINFOHEADER_SIZE 40
+/* bitmapinfoheader fields specified in Microsoft documentation:
+   http://msdn2.microsoft.com/en-us/library/ms532290.aspx */
+struct asf_bitmapinfoheader_s {
+	uint32_t biSize;
+	uint32_t biWidth;
+	uint32_t biHeight;
+	uint16_t biPlanes;
+	uint16_t biBitCount;
+	uint32_t biCompression;
+	uint32_t biSizeImage;
+	uint32_t biXPelsPerMeter;
+	uint32_t biYPelsPerMeter;
+	uint32_t biClrUsed;
+	uint32_t biClrImportant;
+	uint8_t *data;
+};
+typedef struct asf_bitmapinfoheader_s asf_bitmapinfoheader_t;
+
+
+struct asf_iostream_s {
+	/* read function, returns -1 on error, 0 on EOF and read bytes
+	 * otherwise */
+	int32_t (*read)(void *opaque, void *buffer, int32_t size);
+
+	/* write function, returns -1 on error, 0 on EOF and written
+	 * bytes otherwise */
+	int32_t (*write)(void *opaque, void *buffer, int32_t size);
+
+	/* seek function, seeks to offset from beginning of the file,
+	 * returns -1 on error, 0 on EOF */
+	int64_t (*seek)(void *opaque, int64_t offset);
+
+	/* opaque data pointer passed to each of the stream handling
+	 * callbacks */
+	void *opaque;
+
+        /* Data handle passed from Android Multimedia Framework */
+        int data_source_handle;
+
+        /* Bit Stream Position */
+        uint64_t bit_stream_position;
+
+};
+typedef struct asf_iostream_s asf_iostream_t;
+
+struct asf_metadata_entry_s {
+	char *key;	/* key of extended metadata entry */
+	char *value;	/* value of extended metadata entry */
+};
+typedef struct asf_metadata_entry_s asf_metadata_entry_t;
+
+/* all metadata entries are presented in UTF-8 character encoding */
+struct asf_metadata_s {
+	char *title;		/* title of the stream */
+	char *artist;		/* artist of the stream */
+	char *copyright;	/* copyright holder */
+	char *description;	/* description of the stream */
+	char *rating;		/* rating of the stream */
+	uint16_t extended_count;	/* number of extended entries */
+	asf_metadata_entry_t *extended; /* array of extended entries */
+};
+typedef struct asf_metadata_s asf_metadata_t;
+
+struct asf_payload_s {
+	uint8_t stream_number;	/* the stream number this payload belongs to */
+	uint8_t key_frame;	/* a flag indicating if this payload contains a key frame  */
+
+	uint32_t media_object_number;	/* number of media object this payload is part of */
+	uint32_t media_object_offset;	/* byte offset from beginning of media object */
+
+	uint32_t replicated_length;	/* length of some replicated data of a media object... */
+	uint8_t *replicated_data;	/* the replicated data mentioned */
+
+	uint32_t datalen;	/* length of the actual payload data */
+	uint8_t *data;		/* the actual payload data to decode */
+
+	int64_t pts;		/* presentation time of this payload */
+        uint32_t media_object_length; /* Payload Size */
+};
+typedef struct asf_payload_s asf_payload_t;
+
+struct asf_packet_s {
+	uint8_t ec_length;	/* error correction data length */
+	uint8_t *ec_data;	/* error correction data array */
+
+	uint32_t length;		/* length of this packet, usually constant per stream */
+	uint32_t sequence;              /* sequence value reserved for future use, should be ignored */
+	uint32_t padding_length;	/* length of the padding after the data in this packet */
+	uint32_t send_time;		/* send time of this packet in milliseconds */
+	uint16_t duration;		/* duration of this packet in milliseconds */
+
+	uint16_t payload_count;		/* number of payloads contained in this packet */
+	asf_payload_t *payloads;	/* an array of payloads in this packet */
+	uint16_t payloads_size;		/* for internal library use, not to be modified by applications! */
+
+	uint32_t payload_data_len;	/* length of the raw payload data of this packet */
+	uint8_t *payload_data;		/* the raw payload data of this packet, usually not useful */
+
+	uint8_t *data;		/* for internal library use, not to be modified by applications! */
+	uint32_t data_size;	/* for internal library use, not to be modified by applications! */
+};
+typedef struct asf_packet_s asf_packet_t;
+
+struct asf_stream_extended_properties_s {
+	uint64_t start_time;
+	uint64_t end_time;
+	uint32_t data_bitrate;
+	uint32_t buffer_size;
+	uint32_t initial_buf_fullness;
+	uint32_t data_bitrate2;
+	uint32_t buffer_size2;
+	uint32_t initial_buf_fullness2;
+	uint32_t max_obj_size;
+	uint32_t flags;
+	uint16_t stream_num;
+	uint16_t lang_idx;
+	uint64_t avg_time_per_frame;
+	uint16_t stream_name_count;
+	uint16_t num_payload_ext;
+};
+typedef struct asf_stream_extended_properties_s asf_stream_extended_properties_t;
+
+struct asf_stream_s {
+	asf_stream_type_t type;	/* type of this current stream */
+	uint16_t flags;         /* possible flags related to this stream */
+
+	/* pointer to type specific data (ie. waveformatex or bitmapinfoheader)
+	 * only available if ASF_STREAM_FLAG_AVAILABLE flag is set, otherwise NULL */
+	void *properties;
+
+	/* pointer to extended properties of the stream if they specified
+	 * only available if ASF_STREAM_FLAG_EXTENDED flag is set, otherwise NULL */
+	asf_stream_extended_properties_t *extended_properties;
+};
+typedef struct asf_stream_s asf_stream_t;
+
+typedef struct asf_file_s asf_file_t;
+
+/* initialize the library using callbacks defined on a stream structure,
+   the stream structure can be freed after calling this function */
+LIBASF_API asf_file_t *asf_open_cb(asf_iostream_t *iostream);
+
+#ifdef __cplusplus
+extern "C" {
+/* initialize the library using file on a local filesystem */
+LIBASF_API asf_file_t *asf_open_file();
+
+/* close the library handle and free all allocated memory */
+LIBASF_API void asf_close(asf_file_t *file);
+
+/* create a packet structure for reading data packets */
+LIBASF_API asf_packet_t *asf_packet_create();
+
+/* free the packet structure allocated earlier, need to be called only once */
+LIBASF_API void asf_packet_destroy(asf_packet_t *packet);
+
+/* get next packet from the stream to the specified packet structure */
+LIBASF_API int asf_get_packet(asf_file_t *file, asf_packet_t *packet);
+
+/* seek to the closest (key frame) packet specified by milliseconds position */
+LIBASF_API int64_t asf_seek_to_msec(asf_file_t *file, int64_t msec);
+
+
+/* get metadata information of the ASF file handle */
+LIBASF_API asf_metadata_t *asf_header_get_metadata(asf_file_t *file);
+
+/* free metadata structure received from the library */
+LIBASF_API void asf_metadata_destroy(asf_metadata_t *metadata);
+
+/* free all header information from the ASF file structure
+ * WARNING: after calling this function all asf_header_*
+ *          functions will return NULL or failure!!! */
+LIBASF_API void asf_header_destroy(asf_file_t *file);
+
+
+/* calculate how many streams are available in current ASF file */
+LIBASF_API uint8_t asf_get_stream_count(asf_file_t *file);
+
+/* get info of a stream, the resulting pointer and its contents should NOT be freed */
+LIBASF_API asf_stream_t *asf_get_stream(asf_file_t *file, uint8_t track);
+
+
+/* return non-zero if the file is broadcasted, 0 otherwise */
+LIBASF_API int asf_is_broadcast(asf_file_t *file);
+
+/* return non-zero if the file is seekable, 0 otherwise */
+LIBASF_API int asf_is_seekable(asf_file_t *file);
+
+/* get size of the ASF file in bytes */
+LIBASF_API uint64_t asf_get_file_size(asf_file_t *file);
+
+/* get creation date in 100-nanosecond units since Jan 1, 1601 GMT
+   this value should be ignored for broadcasts */
+LIBASF_API uint64_t asf_get_creation_date(asf_file_t *file);
+
+/* get number of data packets available in this file
+   this value should be ignored for broadcasts */
+LIBASF_API uint64_t asf_get_data_packets(asf_file_t *file);
+
+/* get play duration of the file in 100-nanosecond units,
+   this value should be ignored for broadcasts */
+LIBASF_API uint64_t asf_get_duration(asf_file_t *file);
+
+/* maximum bitrate as bits per second in the entire file */
+LIBASF_API uint32_t asf_get_max_bitrate(asf_file_t *file);
+}
+#endif
+#endif
diff --git a/media/libstagefright/include/asfint.h b/media/libstagefright/include/asfint.h
new file mode 100644
index 0000000..2c69671
--- /dev/null
+++ b/media/libstagefright/include/asfint.h
@@ -0,0 +1,141 @@
+/*  libasf - An Advanced Systems Format media file parser
+ *  Copyright (C) 2006-2010 Juho Vh-Herttua
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef ASFINT_H
+#define ASFINT_H
+
+#include <string.h>
+
+#include "asf.h"
+#include "guid.h"
+#include "compat.h"
+
+static INLINE void
+GetGUID(const void *pointer, asf_guid_t *guid)
+{
+	const uint8_t *data = (uint8_t *)pointer;
+	guid->v1 = GetDWLE(data);
+	guid->v2 = GetWLE(data + 4);
+	guid->v3 = GetWLE(data + 6);
+	memcpy(guid->v4, data + 8, 8);
+}
+
+#define GETLEN2b(bits) (((bits) == 0x03) ? 4 : bits)
+#define GETVALUE2b(bits, data) \
+	(((bits) != 0x03) ? ((bits) != 0x02) ? ((bits) != 0x01) ? \
+	0 : *((uint8_t *)data) : GetWLE(data) : GetDWLE(data))
+
+
+
+/* DO NOT MODIFY THE FIRST 3 VARIABLES, BECAUSE THEY ARE
+ * ALSO DEFINED IN asf.h HEADER AND WILL BREAK THINGS */
+#define ASF_OBJECT_COMMON        \
+	asf_guid_t   guid;       \
+	uint64_t     size;       \
+	uint8_t      *full_data; \
+	uint64_t     datalen;    \
+	uint8_t      *data;      \
+	guid_type_t  type;       \
+	struct asfint_object_s *next;
+
+struct asfint_object_s {
+	ASF_OBJECT_COMMON
+};
+typedef struct asfint_object_s asfint_object_t;
+
+struct asf_object_headerext_s {
+	ASF_OBJECT_COMMON
+	asf_guid_t   reserved1;
+	uint16_t     reserved2;
+	struct asfint_object_s *first;
+	struct asfint_object_s *last;
+};
+typedef struct asf_object_headerext_s asf_object_headerext_t;
+
+struct asf_object_header_s {
+	ASF_OBJECT_COMMON
+	uint16_t     subobjects;
+	uint8_t      reserved1; /* 0x01, but could be safely ignored */
+	uint8_t      reserved2; /* 0x02, if not must failed to source the contain */
+	asf_object_headerext_t *ext; /* this is here just for convenience */
+	struct asfint_object_s    *first;
+	struct asfint_object_s    *last;
+};
+typedef struct asf_object_header_s asf_object_header_t;
+
+struct asf_object_data_s {
+	ASF_OBJECT_COMMON
+	asf_guid_t file_id;
+	uint64_t   total_data_packets;
+	uint16_t   reserved;
+	uint64_t   packets_position;
+};
+typedef struct asf_object_data_s asf_object_data_t;
+
+struct asf_index_entry_s {
+	uint32_t packet_index;
+	uint16_t packet_count;
+};
+typedef struct asf_index_entry_s asf_index_entry_t;
+
+struct asf_object_index_s {
+	ASF_OBJECT_COMMON
+	asf_guid_t file_id;
+	uint64_t   entry_time_interval;
+	uint32_t   max_packet_count;
+	uint32_t   entry_count;
+	asf_index_entry_t *entries;
+};
+typedef struct asf_object_index_s asf_object_index_t;
+
+#define ASF_FLAG_BROADCAST 1
+#define ASF_FLAG_SEEKABLE  2
+
+#define ASF_MAX_STREAMS 128
+
+struct asf_file_s {
+	const char *filename;
+	asf_iostream_t iostream;
+
+	uint64_t position;
+	uint64_t packet;
+
+	/* Top level objects */
+	struct asf_object_header_s *header;
+	struct asf_object_data_s   *data;
+	struct asf_object_index_s  *index;
+
+	/* position (in bytes) of data and index objects */
+	uint64_t data_position;
+	uint64_t index_position;
+
+	asf_guid_t file_id;
+	uint64_t   file_size;
+	uint64_t   creation_date;
+	uint64_t   data_packets_count;
+	int64_t   play_duration;
+	uint64_t   send_duration;
+	uint64_t   preroll;
+	uint16_t   flags;
+	uint32_t   packet_size;
+	uint32_t   max_bitrate;
+
+	asf_stream_t streams[ASF_MAX_STREAMS];
+};
+
+#endif
diff --git a/media/libstagefright/include/byteio.h b/media/libstagefright/include/byteio.h
new file mode 100644
index 0000000..b1945e6
--- /dev/null
+++ b/media/libstagefright/include/byteio.h
@@ -0,0 +1,27 @@
+/*  libasf - An Advanced Systems Format media file parser
+ *  Copyright (C) 2006-2010 Juho Vh-Herttua
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef BYTEIO_H
+#define BYTEIO_H
+
+#include "asf.h"
+#include "guid.h"
+
+int asf_byteio_read(asf_iostream_t *iostream, uint8_t *data, int size);
+
+#endif
diff --git a/media/libstagefright/include/compat.h b/media/libstagefright/include/compat.h
new file mode 100644
index 0000000..3d3a490
--- /dev/null
+++ b/media/libstagefright/include/compat.h
@@ -0,0 +1,60 @@
+/*  libasf - An Advanced Systems Format media file parser
+ *  Copyright (C) 2006-2010 Juho Vh-Herttua
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef COMPAT_H
+#define COMPAT_H
+
+#ifdef __GNUC__
+# define INLINE __inline__
+#else
+# define INLINE
+#endif
+
+static INLINE uint16_t
+GetWLE(const void *pointer)
+{
+	const uint8_t *data = (uint8_t *)pointer;
+	return ((uint16_t)data[1] << 8) |
+	       ((uint16_t)data[0]);
+}
+
+static INLINE uint32_t
+GetDWLE(const void *pointer)
+{
+	const uint8_t *data = (uint8_t *)pointer;
+	return ((uint32_t)data[3] << 24) |
+	       ((uint32_t)data[2] << 16) |
+	       ((uint32_t)data[1] <<  8) |
+	       ((uint32_t)data[0]);
+}
+
+static INLINE uint64_t
+GetQWLE(const void *pointer)
+{
+	const uint8_t *data = (uint8_t *)pointer;
+	return ((uint64_t)data[7] << 56) |
+	       ((uint64_t)data[6] << 48) |
+	       ((uint64_t)data[5] << 40) |
+	       ((uint64_t)data[4] << 32) |
+	       ((uint64_t)data[3] << 24) |
+	       ((uint64_t)data[2] << 16) |
+	       ((uint64_t)data[1] <<  8) |
+	       ((uint64_t)data[0]);
+}
+
+#endif
diff --git a/media/libstagefright/include/data.h b/media/libstagefright/include/data.h
new file mode 100644
index 0000000..eec7573
--- /dev/null
+++ b/media/libstagefright/include/data.h
@@ -0,0 +1,28 @@
+/*  libasf - An Advanced Systems Format media file parser
+ *  Copyright (C) 2006-2010 Juho Vh-Herttua
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef DATA_H
+#define DATA_H
+
+#include "asf.h"
+
+void asf_data_init_packet(asf_packet_t *packet);
+int asf_data_get_packet(asf_packet_t *packet, asf_file_t *file);
+void asf_data_free_packet(asf_packet_t *packet);
+
+#endif
diff --git a/media/libstagefright/include/debug.h b/media/libstagefright/include/debug.h
new file mode 100644
index 0000000..4dcdc81
--- /dev/null
+++ b/media/libstagefright/include/debug.h
@@ -0,0 +1,45 @@
+/*  libasf - An Advanced Systems Format media file parser
+ *  Copyright (C) 2006-2010 Juho Vh-Herttua
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef DEBUG_H
+#define DEBUG_H
+
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "asfint.h"
+
+
+#if defined(WIN32) && defined(DEBUG)
+# define debug_printf printf
+#else
+static void
+debug_printf(char *fmt, ...)
+{
+# ifdef DEBUG
+	va_list argp;
+
+	va_start(argp, fmt);
+	vfprintf(stderr, fmt, argp);
+	va_end(argp);
+	fprintf(stderr, "\n");
+# endif
+}
+#endif
+
+#endif
diff --git a/media/libstagefright/include/guid.h b/media/libstagefright/include/guid.h
new file mode 100644
index 0000000..c4a739a
--- /dev/null
+++ b/media/libstagefright/include/guid.h
@@ -0,0 +1,69 @@
+/*  libasf - An Advanced Systems Format media file parser
+ *  Copyright (C) 2006-2010 Juho Vh-Herttua
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef GUID_H
+#define GUID_H
+
+#include "asf.h"
+
+struct asf_guid_s {
+	uint32_t v1;
+	uint32_t v2;
+	uint16_t v3;
+	uint8_t  v4[8];
+};
+typedef struct asf_guid_s asf_guid_t;
+
+typedef enum {
+	GUID_UNKNOWN,
+
+	GUID_HEADER,
+	GUID_DATA,
+	GUID_INDEX,
+
+	GUID_FILE_PROPERTIES,
+	GUID_STREAM_PROPERTIES,
+	GUID_CONTENT_DESCRIPTION,
+	GUID_HEADER_EXTENSION,
+	GUID_MARKER,
+	GUID_CODEC_LIST,
+	GUID_STREAM_BITRATE_PROPERTIES,
+	GUID_PADDING,
+	GUID_EXTENDED_CONTENT_DESCRIPTION,
+
+	GUID_METADATA,
+	GUID_LANGUAGE_LIST,
+	GUID_EXTENDED_STREAM_PROPERTIES,
+	GUID_ADVANCED_MUTUAL_EXCLUSION,
+	GUID_STREAM_PRIORITIZATION,
+
+	GUID_STREAM_TYPE_AUDIO,
+	GUID_STREAM_TYPE_VIDEO,
+	GUID_STREAM_TYPE_COMMAND,
+	GUID_STREAM_TYPE_EXTENDED,
+	GUID_STREAM_TYPE_EXTENDED_AUDIO
+} guid_type_t;
+
+
+int asf_guid_equals(const asf_guid_t *guid1, const asf_guid_t *guid2);
+guid_type_t asf_guid_get_object_type(const asf_guid_t *guid);
+guid_type_t asf_guid_get_stream_type(const asf_guid_t *guid);
+guid_type_t asf_guid_get_type(const asf_guid_t *guid);
+
+#endif
+
diff --git a/media/libstagefright/include/header.h b/media/libstagefright/include/header.h
new file mode 100644
index 0000000..6afa5de
--- /dev/null
+++ b/media/libstagefright/include/header.h
@@ -0,0 +1,29 @@
+/*  libasf - An Advanced Systems Format media file parser
+ *  Copyright (C) 2006-2010 Juho Vh-Herttua
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef HEADER_H
+#define HEADER_H
+
+#include "asf.h"
+
+int asf_parse_header_validate(asf_file_t *file, asf_object_header_t *header);
+void asf_free_header(asf_object_header_t *header);
+asf_metadata_t *asf_header_metadata(asf_object_header_t *header);
+void asf_header_free_metadata(asf_metadata_t *metadata);
+
+#endif
diff --git a/media/libstagefright/include/parse.h b/media/libstagefright/include/parse.h
new file mode 100644
index 0000000..bb8158b
--- /dev/null
+++ b/media/libstagefright/include/parse.h
@@ -0,0 +1,29 @@
+/*  libasf - An Advanced Systems Format media file parser
+ *  Copyright (C) 2006-2010 Juho Vh-Herttua
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+
+#ifndef PARSE_H
+#define PARSE_H
+
+
+int asf_parse_header(asf_file_t *file);
+int asf_parse_data(asf_file_t *file);
+int asf_parse_index(asf_file_t *file);
+
+#endif
+
diff --git a/media/libstagefright/include/utf.h b/media/libstagefright/include/utf.h
new file mode 100644
index 0000000..040ee02
--- /dev/null
+++ b/media/libstagefright/include/utf.h
@@ -0,0 +1,110 @@
+/*  libasf - An Advanced Systems Format media file parser
+ *  Copyright (C) 2006-2010 Juho Vh-Herttua
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef UTF_H
+#define UTF_H
+
+#include <stdlib.h>
+
+#include "asfint.h"
+
+/**
+ * Decode UTF-16LE text from buffer of buflen size and
+ * allocate a new buffer containing the same string
+ * encoded as UTF-8. Supports characters outside of BMP
+ * encoded as an UTF-16 surrogate pair. Returns NULL in
+ * case of allocation failure or invalid surrogate pair.
+ * Buflen is in bytes.
+ */
+static char *
+asf_utf8_from_utf16le(uint8_t *buf, uint16_t buflen)
+{
+	uint32_t length, pos;
+	char *ret;
+	int i;
+
+	length = 0;
+	for (i=0; i<buflen/2; i++) {
+		uint16_t wchar1, wchar2;
+
+		wchar1 = buf[i*2] | (buf[i*2+1] << 8);
+		if (wchar1 >= 0xD800 && wchar1 < 0xDC00) {
+			i++;
+
+			if (i*2 >= buflen) {
+				/* unexpected end of buffer */
+				return NULL;
+			}
+			wchar2 = buf[i*2] | (buf[i*2+1] << 8);
+			if (wchar2 < 0xDB00 || wchar2 > 0xDFFF) {
+				/* invalid surrogate pair */
+				return NULL;
+			}
+			length += 4;
+		} else if (wchar1 > 0x07FF) {
+			length += 3;
+		} else if (wchar1 > 0x7F) {
+			length += 2;
+		} else {
+			length++;
+		}
+	}
+
+	ret = malloc(length + 1);
+	if (!ret) {
+		return NULL;
+	}
+
+	pos = 0;
+	for (i=0; i<buflen/2; i++) {
+		uint16_t wchar1, wchar2;
+		uint32_t codepoint;
+
+		wchar1 = buf[i*2] | (buf[i*2+1] << 8);
+		if (wchar1 >= 0xD800 && wchar1 < 0xDC00) {
+			i++;
+			wchar2 = buf[i*2] | (buf[i*2+1] << 8);
+			codepoint = 0x10000;
+			codepoint += ((wchar1 & 0x03FF) << 10);
+			codepoint |=  (wchar2 & 0x03FF);
+		} else {
+			codepoint = wchar1;
+		}
+
+		if (codepoint > 0xFFFF) {
+			ret[pos++] = 0xF0 | ((codepoint >> 18) & 0x07);
+			ret[pos++] = 0x80 | ((codepoint >> 12) & 0x3F);
+			ret[pos++] = 0x80 | ((codepoint >> 6)  & 0x3F);
+			ret[pos++] = 0x80 |  (codepoint & 0x3F);
+		} else if (codepoint > 0x07FF) {
+			ret[pos++] = 0xE0 |  (codepoint >> 12);
+			ret[pos++] = 0x80 | ((codepoint >> 6) & 0x3F);
+			ret[pos++] = 0x80 |  (codepoint & 0x3F);
+		} else if (codepoint > 0x7F) {
+			ret[pos++] = 0xC0 |  (codepoint >> 6);
+			ret[pos++] = 0x80 |  (codepoint & 0x3F);
+		} else {
+			ret[pos++] = codepoint;
+		}
+	}
+
+	ret[length] = '\0';
+	return ret;
+}
+
+#endif
diff --git a/media/libstagefright/mpeg2ts/ESQueue.cpp b/media/libstagefright/mpeg2ts/ESQueue.cpp
index ff8d7d2..eac1250 100644
--- a/media/libstagefright/mpeg2ts/ESQueue.cpp
+++ b/media/libstagefright/mpeg2ts/ESQueue.cpp
@@ -769,9 +769,24 @@ sp<ABuffer> ElementaryStreamQueue::dequeueAccessUnitMPEGAudio() {
 
     size_t frameSize;
     int samplingRate, numChannels, bitrate, numSamples;
-    CHECK(GetMPEGAudioFrameSize(
+
+    // If the VBR flow will fail the flow will get automatically switched
+    // to CBR.
+    if(GetMPEGAudioFrameSize(
                 header, &frameSize, &samplingRate, &numChannels,
-                &bitrate, &numSamples));
+                &bitrate, &numSamples)) {
+        mFrameSizeCBR = frameSize;
+        mSamplingRateCBR = samplingRate;
+        mNumChannelsCBR = numChannels;
+        mBitRateCBR = bitrate;
+        mNumSamplesCBR = numSamples;
+    } else {
+        frameSize = mFrameSizeCBR;
+        samplingRate = mSamplingRateCBR;
+        numChannels = mNumChannelsCBR;
+        bitrate = mBitRateCBR;
+        numSamples = mNumSamplesCBR;
+    }
 
     if (size < frameSize) {
         return NULL;
diff --git a/media/libstagefright/mpeg2ts/ESQueue.h b/media/libstagefright/mpeg2ts/ESQueue.h
index feb2d6f..9530f5b 100644
--- a/media/libstagefright/mpeg2ts/ESQueue.h
+++ b/media/libstagefright/mpeg2ts/ESQueue.h
@@ -61,6 +61,14 @@ private:
     Mode mMode;
     uint32_t mFlags;
 
+    // Declaring member variables for storing the values for Constant Bit Rate
+    size_t mFrameSizeCBR;
+
+    int mSamplingRateCBR;
+    int mNumChannelsCBR;
+    int mBitRateCBR;
+    int mNumSamplesCBR;
+
     sp<ABuffer> mBuffer;
     List<RangeInfo> mRangeInfos;
 
diff --git a/media/libstagefright/omx/SoftOMXPlugin.cpp b/media/libstagefright/omx/SoftOMXPlugin.cpp
index 934fccc..25b8090 100644
--- a/media/libstagefright/omx/SoftOMXPlugin.cpp
+++ b/media/libstagefright/omx/SoftOMXPlugin.cpp
@@ -79,6 +79,11 @@ static const struct {
     { "OMX.google.raw.decoder", "rawdec", "audio_decoder.raw" },
     { "OMX.google.flac.encoder", "flacenc", "audio_encoder.flac" },
     { "OMX.google.gsm.decoder", "gsmdec", "audio_decoder.gsm" },
+    { "OMX.ST.aac.decoder", "ste_aacdec", "audio_decoder.aac" },
+    { "OMX.google.aac.decoder", "aacdec", "audio_decoder.aeld" },
+    { "OMX.ST.mp3.decoder", "ste_mp3dec", "audio_decoder.mp3" },
+    { "OMX.ST.aac.decoder", "ste_aacdec", "audio_decoder.aac" },
+    { "OMX.ST.AFM.decoder.wmapro_v10", "ste_wmapro_v10", "audio_decoder.wmapro" },
 };
 
 static const size_t kNumComponents =
diff --git a/media/libstagefright/rtsp/AMPEG4AudioAssembler.cpp b/media/libstagefright/rtsp/AMPEG4AudioAssembler.cpp
index aa8ffc6..03ee39c 100644
--- a/media/libstagefright/rtsp/AMPEG4AudioAssembler.cpp
+++ b/media/libstagefright/rtsp/AMPEG4AudioAssembler.cpp
@@ -201,13 +201,33 @@ static status_t parseAudioSpecificConfig(ABitReader *bits, sp<ABuffer> *asc) {
             CHECK_EQ(parseAudioObjectType(bits, &extensionAudioObjectType),
                      (status_t)OK);
 
-            sbrPresent = bits->getBits(1);
-
-            if (sbrPresent == 1) {
-                unsigned extensionSamplingFreqIndex = bits->getBits(4);
-                if (extensionSamplingFreqIndex == 0x0f) {
-                    /* unsigned extensionSamplingFrequency = */bits->getBits(24);
+            if (extensionAudioObjectType == 5) {
+                sbrPresent = bits->getBits(1);
+                if (sbrPresent == 1) {
+                    unsigned extensionSamplingFreqIndex = bits->getBits(4);
+                    if (extensionSamplingFreqIndex == 0x0f) {
+                        /* unsigned extensionSamplingFrequency = */bits->getBits(24);
+                    }
+                    if (bits->numBitsLeft() >= 12) {
+                        syncExtensionType = bits->getBits(11);
+                        if (syncExtensionType == 0x548) {
+                            /* unsigned psPresent */bits->getBits(1);
+                        } else {
+                            // Rewind bitstream so that the reading of second
+                            // syncExtensionType has no effect
+                            bits->rewindBits(11);
+                        }
+                    }
+                }
+            } else if (extensionAudioObjectType == 22) {
+                sbrPresent = bits->getBits(1);
+                if (sbrPresent == 1) {
+                    unsigned extensionSamplingFreqIndex = bits->getBits(4);
+                    if (extensionSamplingFreqIndex == 0x0f) {
+                        /* unsigned extensionSamplingFrequency = */bits->getBits(24);
+                    }
                 }
+                /* unsigned extensionChannelConfiguration = */bits->getBits(4);
             }
 
             size_t numBitsInExtension =
@@ -223,7 +243,7 @@ static status_t parseAudioSpecificConfig(ABitReader *bits, sp<ABuffer> *asc) {
                 bits->skipBits(8 - (numBitsInExtension & 7));
             }
         } else {
-            bits->putBits(syncExtensionType, 11);
+            bits->rewindBits(11);
         }
     }
 
@@ -333,11 +353,14 @@ static status_t parseStreamMuxConfig(
             break;
     }
 
+    status_t parseResult = OK;
     *otherDataPresent = bits->getBits(1);
     *otherDataLenBits = 0;
     if (*otherDataPresent) {
         if (audioMuxVersion == 1) {
             TRESPASS();  // XXX to be implemented
+        } else if (bits->numBitsLeft() < 9) {
+            parseResult = ERROR_MALFORMED;
         } else {
             *otherDataLenBits = 0;
 
@@ -347,13 +370,45 @@ static status_t parseStreamMuxConfig(
                 otherDataLenEsc = bits->getBits(1);
                 unsigned otherDataLenTmp = bits->getBits(8);
                 (*otherDataLenBits) += otherDataLenTmp;
-            } while (otherDataLenEsc);
+            } while (otherDataLenEsc && bits->numBitsLeft() >= 9);
+
+            if (otherDataLenEsc) {
+                parseResult = ERROR_MALFORMED;
+            }
+        }
+    }
+
+    if (parseResult == OK && bits->numBitsLeft() >= 1) {
+        unsigned crcCheckPresent = bits->getBits(1);
+        if (crcCheckPresent && bits->numBitsLeft() >= 8) {
+            /* unsigned crcCheckSum = */bits->getBits(8);
+        } else if (crcCheckPresent && bits->numBitsLeft() < 8) {
+            parseResult = ERROR_MALFORMED;
+        }
+    } else {
+        parseResult = ERROR_MALFORMED;
+    }
+
+    // Verify that only bits are left for byte aligning and that
+    // any remaining bits are 0
+    if (bits->numBitsLeft() / 8 > 0) {
+        parseResult = ERROR_MALFORMED;
+    } else {
+        unsigned remainder = bits->getBits(bits->numBitsLeft());
+        if (remainder != 0) {
+            parseResult = ERROR_MALFORMED;
         }
     }
 
-    unsigned crcCheckPresent = bits->getBits(1);
-    if (crcCheckPresent) {
-        /* unsigned crcCheckSum = */bits->getBits(8);
+    // Check if config string parsing has failed (then probably due to a
+    // malformed AudioSpecificConfig) and if so, assume most common
+    // configuration for the variables after AudioSpecificConfig.
+    if (parseResult != OK) {
+        ALOGW("LATM config string parsing has failed, assuming most common case "
+             "of frameLengthType=0, otherDataPresent=0, and otherDataLenBits=0");
+        *frameLengthType = 0;
+        *otherDataPresent = 0;
+        *otherDataLenBits = 0;
     }
 
     return OK;
diff --git a/media/libstagefright/tests/Android.mk b/media/libstagefright/tests/Android.mk
index 06ce16b..fe787ef 100644
--- a/media/libstagefright/tests/Android.mk
+++ b/media/libstagefright/tests/Android.mk
@@ -1,4 +1,5 @@
 # Build the unit tests.
+ifeq ($(BUILD_STAGEFRIGHT_TESTS),true)
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
@@ -53,3 +54,4 @@ endif
 ifeq (,$(ONE_SHOT_MAKEFILE))
 include $(call first-makefiles-under,$(LOCAL_PATH))
 endif
+endif
-- 
1.9.1

